<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Self Driven</title>
  <subtitle>兴趣是1，坚持是剩下的99</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brainku.github.io/"/>
  <updated>2018-03-03T08:15:41.000Z</updated>
  <id>https://brainku.github.io/</id>
  
  <author>
    <name>苦辛味</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android remove unused resources</title>
    <link href="https://brainku.github.io/2018/02/07/android-remove-unused-resources/"/>
    <id>https://brainku.github.io/2018/02/07/android-remove-unused-resources/</id>
    <published>2018-02-07T07:52:27.000Z</published>
    <updated>2018-03-03T08:15:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中已经很久没有清理资源了，趁着这次删除手机直播的机会再重新研究了下 AS 的 remove unused resource 操作。</p>
<a id="more"></a>
<h4 id="关于-RUR"><a href="#关于-RUR" class="headerlink" title="关于 RUR"></a>关于 RUR</h4><p>Remove Unused Resources （Refactor-&gt; RUR）是 AS 2.0+ 后加进来用来清除未使用资源的操作。在执行引用的分析之后会列出所有未被使用的 drawable/style/string/layout 资源，统一进行清除。</p>
<p>在 AS 刚增加这个操作的时候曾对项目执行过一次，但删除了识别出的文件之后的大量编译错误让我觉得这个操作并不靠谱。而且这个操作无法针对性的设置白名单，貌似‘ 只能’ 在扫描之后手动 exclude 也让觉得很麻烦。<br>项目里面需要设置的白名单不少，所有不是通过 R.xx 方式引用的资源，比如通过 <code>getIdentifier</code> 方式获取的，还有通过反射调用 <code>R.java</code> 域的，这些都没法通过查找引用的方式检查出来。</p>
<h4 id="设置白名单"><a href="#设置白名单" class="headerlink" title="设置白名单"></a>设置白名单</h4><p>这次趁着删代码的机会再找了下删除资源的好方法，看到了官网提到的 <a href="https://developer.android.com/studio/build/shrink-code.html#keep-resources" target="_blank" rel="external">keep resource</a> ：</p>
<blockquote>
<p>如果您有想要保留或舍弃的特定资源，请在您的项目中创建一个包含 <resources> 标记的 XML 文件，并在 tools:keep 属性中指定每个要保留的资源。…将该文件保存在项目资源中，例如，保存在 res/raw/keep.xml。构建不会将该文件打包到 APK 之中。</resources></p>
</blockquote>
<p>像下面这样定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- keep.xml</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">    <span class="attr">tools:keep</span>=<span class="string">"</span></div><div class="line">    @layout/l_used*_c,</div><div class="line">    @layout/l_used_b*"</div><div class="line">    <span class="attr">tools:discard</span>=<span class="string">"@layout/unused2"</span> /&gt; // discard 表示需要删除的资源，不大常用</div></pre></td></tr></table></figure>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>既然 <code>shrinkResources</code> 会读这个配置，那抱着 RUR 是不是也会的想法尝试了一下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">           <span class="attr">tools:keep</span>=<span class="string">"</span></div><div class="line">           @drawable/face_*,</div><div class="line">           @dimen/*,</div><div class="line">           @style/*,</div><div class="line">           @string/*,</div><div class="line">           @color/*,</div><div class="line">           @array/*"/&gt;</div></pre></td></tr></table></figure>
<p>这个配置文件会忽略以 <code>face_</code> 结尾的 drawable 资源跟所有的 style/dimen/string/color/array 未使用资源。<br>实际执行了一次，扫描结果确实是忽略了这些未使用资源。结果看起来不错，1k 个文件，尝试删除并编译，果然还是报错了。<br>提示信息是说找不到特定布局跟 id，RUR 的引用判断还是有问题吗？粗略看了出错的几个文件，引用 id 的这个类还在使用，对应的布局不应该被删吧。<br>先不深究，把被误删的布局加进 keep 文件，然后恢复之前 RUR 删除的文件重新执行 RUR。<br>注意这里最好不要单独 revert 误删的文件，布局文件里还可能引用其他布局或者资源，在上次清除时可能连带被删，还得再找出这些资源一个个 revert，没准还带递归引用。<br>这次再跑 RUR 可以正常运行了，随便再在其他分支看了几个被删除的布局也确实没引用，RUR 操作成功了。</p>
<h4 id="深究白名单文件"><a href="#深究白名单文件" class="headerlink" title="深究白名单文件"></a>深究白名单文件</h4><p>删完资源再来看看几个被加进白名单的布局。</p>
<h5 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h5><p>尝试搜了其中一个布局，<code>layout_game_room_landscape_bottom</code>。在代码里面搜不到这个布局的引用，但直接删除之后项目就编译出错了，提示找不到对应 id 的资源。<br>原因 Get，这类布局删掉报错其实就是布局真没再使用，但是 id 仍然在代码里被引用导致的。find 这些 id 的操作实际只会返回 null，但因为加了非空判断，项目里不会崩。后面要做的就是把这块业务对应的代码一起删掉，不能只删布局。</p>
<h5 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h5><p>排除了白名单里上面这类布局之后，还剩下一类布局，这类布局有个共性就是布局只被用在 <code>new XXBaseAdapter(context, R.layout.xxx)</code> 这个构造函数里。只要构造函数传入的布局就会被删除？<br>仔细想了下不大可能，因为 ArrayAdapter 的构造函数就是 <code>ArrayAdapter(context, layoutId)</code>，这可能一下子就会误判很多布局。<br>另外写了一个 demo 来验证最小被误删除的原型，最后发现是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.layout_simple_remove) &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>如果 <code>R.layout.layout_simple_remove</code> 只在这里被引用，那 RUR 就会提示这个布局未被引用可删除。如果去掉后面的匿名类实现声明，这个布局的引用又能被正常找出来了。bug 无疑，不过竟然没人提过，是不是这操作都没什么人用呢。</p>
<p>资源删除 done，目前看似乎没什么问题，静待回归。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中已经很久没有清理资源了，趁着这次删除手机直播的机会再重新研究了下 AS 的 remove unused resource 操作。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://brainku.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://brainku.github.io/tags/android/"/>
    
      <category term="andriod studio" scheme="https://brainku.github.io/tags/andriod-studio/"/>
    
      <category term="优化" scheme="https://brainku.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello Kotlin</title>
    <link href="https://brainku.github.io/2017/05/19/hello-kotlin/"/>
    <id>https://brainku.github.io/2017/05/19/hello-kotlin/</id>
    <published>2017-05-19T11:32:37.000Z</published>
    <updated>2017-08-19T14:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>估计过段时间就会冒出一堆 5 分钟 kotlin 快速入门了，反正我就不凑这个热闹了（。）</p>
<p>想想我接触 kotlin 并没有多早，起码不是 beta 版开始的用户。如果不是这次 IO，我大概会把 kotlin 直接就丢在那里吧。</p>
<a id="more"></a>
<blockquote>
<p><em>16.02.16 玩一下kotlin【把教程的quiz都pass了</em></p>
</blockquote>
<p>一年前 kotlin 出 1.0 的时候，我当时还决定了好好玩一下。当然也只是玩一下而已，很快就放下了。今年决定学一门新语言的时候又把 kotlin 捡了起来，起码是把文档都翻完了，但敲了些 demo 之后又没怎么用了。<br>直到这次 IO。</p>
<hr>
<p>IO 的第一天，那天早上我起得有点晚，刷了一下推之后发现 JetBrain 写了篇「<a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/" target="_blank" rel="external">kotlin on android now official</a>」，offical？？瞬间清醒了。赶紧继续往下翻，找到 Google 官方提到这件事的推，这竟然是真的？！<br>kotlin 真的成为了 Android 的 first-class language，以后再也不用担心官方搞 Jack&amp;Jill 这种对其他语言不友好的工具链了~！</p>
<hr>
<p>之前用 kotlin 出的时候就一直在担心没有官方支持的语言哪天会不会出事。<br>16 年 3 月，在 Google 说他们在搞 <a href="http://developer.android.com/intl/zh-cn/preview/j8-jack.html#supported-features" target="_blank" rel="external">Jack&amp;Jill</a> 的时候我就有 bingo 的感觉。使用 Jack 编译的 library 不会经过生成 class 文件这一步，合并之前已经是  dex 了。这对实际是编译成字节码的 kotlin 的影响可以说是致命的。如果 Google 哪天真的主推了 Jack（只是更新一个 tools 的事），那 kotlin 该怎么办？</p>
<p>但过了一年之后，这个问题突然被解决了。<br>Google 放弃了他们的 <a href="https://android-developers.googleblog.com/2017/03/future-of-java-8-language-feature.html" target="_blank" rel="external">Jack 计划</a>。Java8 的特性仍然会通过 javac 的方式实现，还是熟悉的 .class，于是使用 kotlin 最大的问题解决了。<br>再然后就是今年的 IO 看到 kotlin 成为官方语言的好消息了。可喜可贺~</p>
<hr>
<p>后来看视频，官方宣布了在周五会有两场关于 kotlin 的演讲，其中一位是 Square 的 Jake Wharton。我突然才意识到，JW 最近在 medium 更新的那么多篇 kotlin 相关的文章代表什么意思。<br>Google 必须是提前就跟他打好交道了，所以 JW 才会在他们的团队博客上<a href="https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17" target="_blank" rel="external">推广 kotlin</a>。<br>JW 在 15 年就写了<a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?usp=sharing" target="_blank" rel="external"> 22 页文档</a>在团队里推广 kotlin，真佩服他有远见。不过也多亏 JW 的号响力吧，这两年来真的没少提过 kotlin，google 在文章里也引用了他的某次演讲。最近 JW 还会参加 kotlin 团队举办的 <a href="https://www.kotlinconf.com/" target="_blank" rel="external">KotlinConf</a>，真期待这个会议会讲什么有趣的内容。</p>
<hr>
<p>我现在也得好好充电了，三月翻完文档，敲了demo之后，我又停下来了。kotlin 刚加进去的 coroutines 也没怎么去了解。<br>现在唯二两本关于 kotlin 的书，其中一本是 <a href="https://leanpub.com/kotlin-for-android-developers" target="_blank" rel="external">Kotlin for Android Developers</a>，不过好贵orz<br>翻了 sample 没有什么实质内容（连全目录都没有），还不如自己好好看文档呢。<br>为什么国外的 sample 都这么小气啊……</p>
<p>但比起书，果然更重要的还是 side project 啊。得做一个长期坚持下去的项目，这样新的东西才可以用上去。多用才是学语言最好的方式，总得有实践才行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;估计过段时间就会冒出一堆 5 分钟 kotlin 快速入门了，反正我就不凑这个热闹了（。）&lt;/p&gt;
&lt;p&gt;想想我接触 kotlin 并没有多早，起码不是 beta 版开始的用户。如果不是这次 IO，我大概会把 kotlin 直接就丢在那里吧。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://brainku.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://brainku.github.io/tags/android/"/>
    
      <category term="kotlin" scheme="https://brainku.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>《君の名は》と《Another Side：EarthBound》</title>
    <link href="https://brainku.github.io/2017/05/17/about-kiminonawa-to-another-side/"/>
    <id>https://brainku.github.io/2017/05/17/about-kiminonawa-to-another-side/</id>
    <published>2017-05-17T13:11:05.000Z</published>
    <updated>2017-05-17T13:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客回归计划稳定进行中。<br>这次依然主要是书评，不过是关于去年一部很火的电影。当时是考完 N2 去看的，所以印象比较深。再加上我把原作的两本小说都看完了（还是生肉），也都写了不少评价，这次稍微整理一下。</p>
<a id="more"></a>
<h4 id="关于电影"><a href="#关于电影" class="headerlink" title="关于电影"></a>关于电影</h4><p>我蛮喜欢这部电影的画面跟音乐的。<br>新海诚的电影画的每一帧几乎都可以单独拿出来当壁纸，尤其是一开始流星落下的场景，在电影院看的时候特别让人震撼。<br>不知道怎么评价音乐，但跟电影特别「称」是毋庸置疑的。「前前世世」作为 OP 也特别耐听。<br>电影确定在国内上映的时候，我决定了在电影上映前先把原作小说翻完了，生肉。<br>其实也不可以说是原作吧。新海诚是在电影的制作途中写的这本书，像是把当时的剧本改编的，算是「轻小说化」？但小说在电影上映前就已经开始卖了也很神奇。当时就觉得新海诚应该是对电影特别有自信吧。</p>
<h4 id="本：《君の名は》"><a href="#本：《君の名は》" class="headerlink" title="本：《君の名は》"></a>本：《君の名は》</h4><p>说实话，我并不怎么喜欢新海诚写的这本小说。<br>看完小说的那晚写了这些评论：</p>
<blockquote>
<p>小说完成。我果然还是不习惯跟这类似的题材，跟之前看完《解忧杂货店》有类似的感觉。日常里混着不少非日常的东西了，经常会一下子出戏，尤其是涉及到「时间悖论」的更加难以接受。看后记发现小说是电影制作过程中才写的，也就是所谓的小说化作品，但是小说比电影更早出来也是神奇。看完小说之后仍然会去体验电影，大概就是有这样的自信吧。 -16.11.26</p>
</blockquote>
<p>题材上就跟东野的《解忧杂货店》一样都是穿越，只是前者还包括了换身。但只要涉及到时间相关的，解释稍微有点突兀我就很难接受。</p>
<p>说说小说跟电影的区别吧。按照新海诚监督的说法是：</p>
<blockquote>
<p><em>小説版は瀧と三葉の一人称、つまり二人の視点のみで絵かれている。彼らが知らないことは語れないのだ。一方、映画はそもそも三人称ーーつまりカメラが映し出す世界である。だから、瀧と三葉以外の人々も含めて文字通り俯瞰で語れるシーンも多くある。</em></p>
</blockquote>
<p>小说版是以泷和三叶的视点讲述的故事，无法讲述他们两个无法知道的故事。而电影则本来就是相机下映照出来的世界，会包含泷和三叶之外包含第三人称，即俯瞰下的场景。<br>事实上，电影里出现的这些第三人称场景，大多是在《Another Side》里补完了。尤其是最后的结局，穿越回到流星落下那晚的三叶跑到了镇长办公室，她对她父亲到底说了些什么。为什么最后会举行演戏让村里大部分人都躲过了一难。<br>说是让人随意想象，好像也不是。因为这些全在外传里说了，以再来一部电影还差不多的份量。</p>
<h4 id="本：《Another-Side：EarthBound》"><a href="#本：《Another-Side：EarthBound》" class="headerlink" title="本：《Another Side：EarthBound》"></a>本：《Another Side：EarthBound》</h4><p>当初想看外传是因为正传里有很多没有讲清楚的东西。比如说，千年前的那场灾害，还有电影里穿越之后最后的场景，为什么作为镇长的宫水俊树为什么会听三叶的话。<br>但看到的是比正传更多的揉おっぱい，从瀧开始，到妹妹四叶换身一直都是。嗯。<br>除去第一第二话讲述瀧跳迈克尔杰克逊月步跟勅使河原建咖啡厅的故事，后半的三和四话都都跟主线有关。<br>第三话是妹妹喝了代表自己半身的酒晚上穿越到祖母（*N）那个时代的故事。她在这里学会了巫女的舞蹈，还有知道千年前的灾害如何躲过去的。最重要的是在这里了解到了宫水一家是「倭文神の裔」。</p>
<blockquote>
<p><em>梶（かじ）の木や麻などで青赤などの縞を織り出した古代の布 – 《大辞林》</em></p>
</blockquote>
<p>这其实就是在电影里面一叶（也就是祖母）教三叶和四叶织的那种布。<br>她们一族是布神的后裔，每一代的女性都具有可以穿越到某个时代，协助族人躲过灾难的能力。或者说她们身上有着一种与未来连接的「結び」。</p>
<p>接下来的第四话则是在说明，这种称为「結び」的能力是如何影响到三叶和瀧的故事的。<br>原本只是在研究日本古神传承的俊树来到了二叶家的神社，在她们聊天的过程，二叶突然「告白」了！惊，超展开。据本人透露，就是一见钟情了。嗯。<br>两情相悦，但是作为母亲的一叶反对作为巫女继承人的女儿嫁出，所以俊树入赘成为了宫水俊树。<br>一切都是如此美好，还生下了三叶和四叶。但，二叶突然得了莫名其妙的病，还不愿意去大医院治疗，而且一叶（跟村里人？）也不愿意二叶到外面去，最后二叶死了，俊树非常伤心，抛弃女儿和老丈人离开出走。他觉得他要当上镇长，改变村里这些人这些死板的想法。<br>现在时间来到了流星落下那晚，在看到三叶之后，俊树正想说些什么，但突然想起了那个流星的谜题，这个他跟二叶一直都解不开的千年前留下来的谜题，他好像终于知道了答案。他现在会在这里全是因为布神的引导，为了在这里引导大家躲过灾难。<br>后续则是电影里提到的，举行灾难演戏，并因此拯救了村里大多数人。</p>
<p>我很难接受这最后的第四话。无论他多想跟我解释说这是「結び」，在我看来这只是个可怕的宿命而已。<br>当初看完的书评：</p>
<blockquote>
<p>「今、自分が、この立場で、ここにいるということが、定められたひとつの導きだというのか」看到最后有种命运论的不愉快感，这个人从与二葉相遇，入赘，丧妻，参选镇长全在神的控制下，只为躲过天灾。这个故事设定伏笔太多了，电影塞不下只能丢外传。有些本该在电影里的吧，不然就不是一个完整的故事。-17.1.2</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客回归计划稳定进行中。&lt;br&gt;这次依然主要是书评，不过是关于去年一部很火的电影。当时是考完 N2 去看的，所以印象比较深。再加上我把原作的两本小说都看完了（还是生肉），也都写了不少评价，这次稍微整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="小说" scheme="https://brainku.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="日语" scheme="https://brainku.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="电影" scheme="https://brainku.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="生肉" scheme="https://brainku.github.io/tags/%E7%94%9F%E8%82%89/"/>
    
  </entry>
  
  <entry>
    <title>迟到的 N2 总结</title>
    <link href="https://brainku.github.io/2017/05/14/way-to-learn-japanese/"/>
    <id>https://brainku.github.io/2017/05/14/way-to-learn-japanese/</id>
    <published>2017-05-14T06:25:33.000Z</published>
    <updated>2017-05-17T13:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>最近翻了一本《双语者》的小书，想起了我考完 N2 之后还没写过总结，所以趁着这个机会，把之前的都补上来。</p>
<a id="more"></a>
<h4 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h4><p>17年3月15号，收到了纸质版的 N2 证书。比预料地薄很多，而且似乎也跟在日本留学的同学的证书不大一样。嘛，总之是拿到证了，花了一年时间准备的能力测试。<br>17年1月25号，查成绩。其实在24号就已经可以查了，只是我隔天才知道。紧张地找出准考证号输入信息，看到168的时候松了口气，比平时的真题模拟又高了一点，还好还好。<br>16年12月4号，JLPT 考试当天。久违地去了南校，考前还找柱子聊了半天。真正的考场似乎还给自己加了一个 buffer，1小时45分的笔试，自己用了不到1个小时做完。平时自己模拟做题，顶多就剩下15分钟。考完那天还去看了《君の名は》。　<br>15年10月21号，我开始学日语那天。</p>
<h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>在更早之前，在高中的时候我就买过一本《日语单词书》，不过却卡在五十音，后面的内容翻都没翻，现在书都扔了。<br>大四的时候又去买了一套新标日初级（上下），但买完之后还是丢在那里直到毕业都没翻过。<br>从没想过我重新捡起日语会是在工作之后。工作之后两个月，我开始受不了那种一下班就玩游戏到睡觉，没有任何长进的生活。我寻思着找些什么来做，最后决定就是恶补算法还有日语。<br>然而这种决定就跟每年的新年愿望清单一样扯淡。<br>15年这一年，我花在日语上的时间是33.2小时（2.5+18.6+12.1+5.9)，还比不上我16年3月份一个月花在日语上的时间（41.8）。<br>真正发生改变是在16年过完春节回来之后一段时间。偶然发现了好用的工具，因此喜欢上了背单词。给自己定了一个「12月考 N2」的目标，开始从259开始倒计时的生活。<br>想到哪天自己可以愉快地看生肉，我就再也没法停下来。以往在懒觉中度过的周末，我也好好地利用起来了。也就是这个月开始，iHour 的统计时间破百了。<br>这段差不多都是每天早上7点起床，一直看书看到8点半出门。晚上回来洗完澡，花半个小时复习单词，剩下的时间再翻翻技术书。这种规律的生活也是久违了。之前经常睡到8点20分才起来，折腾完就去上班。晚上回来也只是玩游戏。<br>这种像是学生时代一样生活，意外地不怎么辛苦。起码我不会再冒出「今天依然无所事事」的罪恶感，像现在这样。</p>
<h4 id="后日谈"><a href="#后日谈" class="headerlink" title="后日谈"></a>后日谈</h4><p>考完 N2 那天，久违了发了朋友圈纪念一下。之前决定了没考完 N2，坚决不开它。然而也就是这样子了，这个仪式结束了。<br>12月考完 N2 之后，我失去了目标，直到现在也还是。<br>原本打算接手的另外的一个目标并没有怎么被重视，完全没动力去执行。所以这两者到底有什么区别？没搞懂。现在过得有些浑浑噩噩。我想要的到底是什么。<br>最近又想着把 N1 考了。「既然没有目标，暂时先用这个试下」，这种想法真的可以称为动力吗。</p>
<hr>
<h3 id="踩坑之路"><a href="#踩坑之路" class="headerlink" title="踩坑之路"></a>踩坑之路</h3><p>我总是要绕上不少弯之后才会走上正路。</p>
<h4 id="关于笔记"><a href="#关于笔记" class="headerlink" title="关于笔记"></a>关于笔记</h4><p>从手抄笔记到用备忘录，我真的走了不少弯路也说不定。</p>
<p>一开始是手抄笔记，每课的语法点都详细地抄到笔记里。然而一点都没有复习。<strong>在看新课的时候经常需要往前翻笔记，不过因为笔记比书精简很多，找起来方便得多。</strong>初期靠着这种「作笔记」就好的想法撑过了新标日入门的几道卡，总之是坚持下来了。</p>
<p>开始新标日中级之后，因为语法点剧增，我就停掉了这种行为。只是「看完」单词跟语法，对着语法翻每一课的正文，如果提到了之前的语法点，我又往前翻。<strong>这时的效果比手抄笔记的时候更惨了。翻过的东西觉得自己已经记住了，然而重新看的时候仍然像新的东西一样。花了时间，却一点效果都没有。</strong></p>
<p>强行翻完新标日中级之后，我又开始复习初级的语法（鬼知道我当初怎么决定的）。看到荧光笔的高亮效果，我觉得我发现了好方法。<br>我开始拿着荧光笔画重点了。看书的时候特别勤奋，觉得哪里都是重点，还分了好几种颜色来区分「重点」跟「不知道怎么翻译」之类的东西。<strong>然而效果还是极其糟糕。我根本记不住我标过的重点，事实证明不复习什么都是扯淡。然而想在空闲的时间里复习，带书非常不现实。</strong></p>
<p>高亮的方式一直到后期专题复习的时候都在使用，只是这次我又开始记笔记了，但这次是在Mac的备忘录上。以前也有试过在电脑上作笔记，但是因为当时词汇量太低，输入太慢（尤其是一堆汉字），感觉效率太低就停下来了。但后期词汇已经快1W了，输入不再需要频繁查词典，在电脑上记笔记的效率比手写也许还快不少。最最最重要的是，用备忘录之后我就可以在手机和平板上复习了。饭前排队，饭后休息，只要有时间就拿出来看下。复习时间多了记得的东西也多了。只是总感觉记忆效率不是太高。</p>
<p>考前前几天，复习语法的时候我试着用思维导读来总结语法。图的方式看起来直观多了，也好像更容易记，但因为只试验过几天，实际有多少效果并不清楚，之后有机会再尝试（哪天考N1的时候）。</p>
<p>说到这里，我的笔记优化之路就差不多了。虽然方法很土，但<strong>记笔记，多复习就是王道</strong>。我绕了一堆弯路之后才找到了适合自己的方式。看那几本语法书的时候我曾怀疑过「匆忙翻完书高亮文本」这种行为是否有意义。而我一直没有做出改变，与其说是坚持不如说是害怕「改变」，还好最后停下来思考了。<br>如果方向错了，勤奋这种事也许没多少意义。</p>
<h4 id="关于背单词"><a href="#关于背单词" class="headerlink" title="关于背单词"></a>关于背单词</h4><p>背单词。从五十音都不熟练开始到1W4的单词。</p>
<p>新标日，强行记五十音（这个记不住怎么样都没法继续）。即使到现在，我的片假名还是不熟练= =网上一堆什么巧记，我是记不住。每天起来看好几遍，再一遍遍默写。反正我就是这么笨。</p>
<p>一开始根本没有意识到背单词的问题。初级的时候是先看几遍最后的单词，读几遍就开始抄语法了。后来发现后面的文章用了一堆之前的单词，觉得这样子不行，给自己定了一个一周记多少个单词的目标。虽然目标定了，但如何执行呢？我一点也没有意识到这个问题，最后不了了之。</p>
<p>忽视了单词的我，在新标日初级上之后可以说是一点进展都没有。直到用上了背词软件。<br>用上了背词软件之后，我可以坚持每天打卡记单词了。按月统计的数量非常直观，而且每个关卡的测验确实可以测到我有没有好好记单词。不熟练的单词也好好加到了单词本里。按照这样的节奏，也许到12月的时候还可以把N1的单词都背完。然而我又发现问题了。</p>
<p>虽然把生词加到了复习本里，但我一点也没有复习的意愿。单词变成了如果一开始没记住，下次看到又跟全新的一样这种的存在。进入中级之后，这种大量忘词的现象大量出现，这样下去真的不行了。<br>这次我跟笔记一样求助于备忘录。我按照「词性」，「是否有趣」，「是否容易搞错」这样的类别把之前遇到过的单词分了类。比较难记的单词也会加上例句去辅助记忆。每天固定背60~100个词，晚上回去再花半个小时整理。最重要的是方便复习了，跟语法这些内容一样定期在手机或平板上过一遍。另外，考前也可以只用这些来作为重点复习。<br>虽然花在分类上的时间不少，但收获的东西一定比单纯死记硬背要多不少。</p>
<h4 id="关于工具（软件）"><a href="#关于工具（软件）" class="headerlink" title="关于工具（软件）"></a>关于工具（软件）</h4><p>我的每次改变都是遇到了好用的软件也说不定。起码 iHour 跟沪江的开心词场帮了我不少忙。</p>
<p>看着 iHour 的数字增加特别有成就感，所以我才可以忍着枯燥，挤出自己的时间去背单词，看语法，作笔记。开心词场也是同理，数字在一天天稳定增长这件事是让我坚持记单词这种枯燥行为的最大动力之一。<br>辞典这个也不用说了，学外语的人应该人手必备吧。当初买了 BIGLOBE《新明解七》之后我买辞典的手就停不下来了，现在手机里面装了一堆日日辞典跟英英辞典。前阵子还重新买了《大辞林》跟《新明解七》，用物书堂的辞典换掉了 BIGLOBE 两本糟糕的辞典。<br>但如果说只推荐一本，果然还是《新明解七》，有语音，解释也比较足，有些词还会有「有趣」的源说明，因为好玩，这种词特别容易记。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;最近翻了一本《双语者》的小书，想起了我考完 N2 之后还没写过总结，所以趁着这个机会，把之前的都补上来。&lt;/p&gt;
    
    </summary>
    
      <category term="外语" scheme="https://brainku.github.io/categories/%E5%A4%96%E8%AF%AD/"/>
    
    
      <category term="日语" scheme="https://brainku.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="自学" scheme="https://brainku.github.io/tags/%E8%87%AA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《Android应用性能优化最佳实践》个毛线</title>
    <link href="https://brainku.github.io/2017/05/07/read-android-performance-best-practice/"/>
    <id>https://brainku.github.io/2017/05/07/read-android-performance-best-practice/</id>
    <published>2017-05-07T03:56:19.000Z</published>
    <updated>2017-05-17T13:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>有好长一段时间没留意过（快有一年了说不定）市面上 Android 相关的开发书籍了。前几天面试完的时候领导突然让我给他推荐几本 android 开发相关的「好书」，我才又去亚马逊翻了一下排行榜。<br>《Android应用性能优化最佳实践》这本书给我留下了一点印象，作者好像很厉害，T家音乐的十年总监，评价也都是五星。唔，看起来不错，只是没看过不好评价。晚上写清单给领导的时候他竟然刚好也提到了这本书，这么多人推荐，大概不是雷，速度买了电子版晚上回去看。</p>
<p>结果还是踩到雷了= =</p>
<a id="more"></a>
<p>第一章就说 AS 多好多快的时候我就有点不愉快了。AS这种吃内存，每次更新都要折腾人的IDE还吹得那么好。即时现在稳定多了，但偶尔莫名其妙的问题，吃我16G内存这种事我还是受不了。</p>
<p>第二章开始我就发现了不少小错误，有些还是 Java 基础的问题，我开始有种「这作者行吗」的感觉。</p>
<p>而真正可怕的是从第三章开始。从他开始讲GC那一小节开始之后，我就基本看不下了。<br>这个人真的有了解过 Android GC 吗，感觉他就是在强行解释。无论是可达性，还是Android用的 GC 算法，每个都讲得特别扯淡。最可怕的是 GC 的分代模型他竟然是拿 Hotsport 的图片来讲的。喂喂喂，Hotspot 是什么，Dalvik 又是什么？Dalvik 里新生代还分了两个 Survivor ？而且还是用了 copy？糟点太多了根本数不过来。之后只要一讲到GC，我全选择跳过，受不了这么扯淡的。</p>
<p>后面那些章节，我还发现不少了未注明来源的「引用」。<br>首先是代码的引用。<br>监控检测那里说是介绍某些「监控框架」的代码，然后开始大段大段地改别人的开源项目，到最后也没写这个项目是什么。对比过他改后的代码，大致就是一些命名的区别，其他的基本一致。另外有区别的就是自己加了一个所谓的上报接口？<br>书里还有些是国外博客和官方文档的翻译。<br>最后两章讲 JobScheduler 跟 Doze 的那些内容没多少是原创的吧。话说，我真想说，翻译也得上心点，不要忘记翻「and」这种连接词，一看到这个词都没翻译，马上去搜原文，然后 bingo= =</p>
<p>整本书到底有多少是原创内容就不说了。就是有些观点跟数据，我真希望他能附个链接说下来源。<br>他说 HWRendering 有限制，还列了几点。这个官方没提到过，网上搜了一下，找到了一篇 <a href="https://plus.google.com/+DianneHackborn/posts/2FXDCz8x93s" target="_blank" rel="external">2011 年的文章</a>，这个可信，应该也就是照着这说的。但是他说 HWRendering 有缺陷，还说某些情况下不刷新。然而没有代码，没有 demo，也没有来源，这我就非常怀疑了。这种问题起码会是个 issue 吧，可是我也搜不到。这是不是个脑补的缺陷。</p>
<p>真庆幸这次买了电子版，不然我还得考虑怎么扔掉。<br>从15年到现在，国内出了不少 Android 相关的书了，但结果我能推荐的还是只有15年前看过的那几本。<br>而这还是一位十年总监写的优化书，再考虑之前某旅游应用总监写的某本书，我真的怀疑是不是因为国内有能力的人都不屑于写书。也确实，国内的书这么便宜，版税也收不了多少。可是还是希望哪天可以见到几本像样的 android 书啊（。</p>
<p>看本书要这么较真也是久违了，上次还是照着原文吐槽的垃圾回收的算法与实现= =不过那次只是吐槽翻译。</p>
<h2 id="边看边整（tu）理（cao）的内容："><a href="#边看边整（tu）理（cao）的内容：" class="headerlink" title="边看边整（tu）理（cao）的内容："></a>边看边整（tu）理（cao）的内容：</h2><p>有种硬着头皮读下去的感觉，不知道的东西可以这么扯。5.6<br>按照章节的顺序写一下。</p>
<p>2.5.1 应用启动流程</p>
<ul>
<li>「每个应用只对应一个 Application 对象」– 多进程情况下会有多个。后面说的不同 Activity 和 Service 获得的对象都是同一个对象同理。</li>
<li>「…重写的 Application 类后，看看该类可以重载的抽象接口」–Application 不是抽象类，没有抽象接口。</li>
<li>「<code>onTerminate()</code> 应用结束时调用」 – 这个方法只有模拟器会调到。</li>
</ul>
<p>2.6.3</p>
<ul>
<li>讲 ListView 的局部刷新说 <code>notisfyDataSetChanged()</code> 是什么鬼。。只有 RecyclerView 可以做列表的局部刷新吧。<br>2.7.2</li>
<li>「这时点击事件是绝对不会触发的」—这时你做了什么啊orz（在新位置点击控件）</li>
</ul>
<p>2.8.2 （卡顿检测）代码实现</p>
<ul>
<li>实现 UiPerfMonitorConfig 竟然只是为了里面的常量。。。还有里面的 public 修饰符也是多余的。为什么不要实现只有常量的接口：<a href="http://stackoverflow.com/questions/2659593/what-is-the-use-of-interface-constants" target="_blank" rel="external">constant interfaces</a>  （不过之前见过 JarkWharton 的代码也有定义常量接口这一习惯，确实没见过实现这种接口）</li>
<li>这里就是把 BlockCanary 又重新造了一次轮子，而且应该说主要的代码都是一模一样的。唔，竟然没有出处说明 <a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">BlockCanary</a></li>
<li><code>LogWriter.writeLog4SampleFile()</code>，从网上拷贝的代码注释没删掉（。</li>
</ul>
<p><strong>表示他一说到垃圾回收我就懵逼（。我真的不知道有哪些是可以信的了。</strong><br>3.1.1 内存管理机制</p>
<ul>
<li>「回收器发现该对象不可达」-标记清除算法会有不可达对象回收，但是标记压缩算法是只对可达对象进行拷贝操作而已。说基于6.0了，5.0之后引进来的这个压缩操作不提一下？：<a href="https://source.android.com/devices/tech/dalvik/gc-debug" target="_blank" rel="external">gc-debug</a> , <a href="http://stackoverflow.com/questions/13347372/android-gc-internals" target="_blank" rel="external">android-gc</a></li>
<li>把对象引用置为null可以提升回收效率？分情况吧。Android 的 VM 是有 JIT 的，局部变量置 null 没多少意义。。<a href="https://www.zhihu.com/question/52997759" target="_blank" rel="external">R大 null</a></li>
</ul>
<p>3.1.3 内存回收机制</p>
<ul>
<li>Android 的堆分代是这样子的？真希望他给个地址参考下，书里给的图片是 Hotspot JVM 的分代模型：<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="external">java gc</a></li>
<li>「Stop World是由于并发GC时，其他线程都会停止」。首先，这里是「stop the world」，然后这里是「并行」，并行跟并发并不一样。其次，STW是因为要标记从GC Root出来的对象，跟并不并行没关系。或者说并发就是尽量减少STW，跟 allocation 同时进行才叫并发。</li>
</ul>
<p>3.1.4 GC类型</p>
<ul>
<li>「GC_FOR_MALLOC ：Malloc GC」？？只是因为没空间创建对象而进行GC，怎么变成这种定义了。<a href="https://developer.android.com/studio/profile/investigate-ram.html#LogMessages" target="_blank" rel="external">GC LogMessages</a></li>
<li>什么时候 Large Object Space 不在堆上了。从3.0之后，Bitmap就已经挪到了heap上。ART上的这块空间也只是堆的某部分而已：「Also, there is a separate heap for large objects like bitmaps, making it faster to find memory for these large objects without wading through the potentially fragmented regular heap. 」：<a href="https://medium.com/google-developers/developing-for-android-i-understanding-the-mobile-context-fd2351b131f8" target="_blank" rel="external">understand the mobile context</a></li>
<li>关于Java上内存泄漏的定义，更能接受 Effective Java 上提到的「unintentional object retention（无意识的对象持有）」这种说法。不是「GC没有把这些辨认出来」，而是你的姿势不对，GC没把该回收的回收掉那可是不尽责。</li>
</ul>
<p>3.4.3 常见内存泄漏场景</p>
<ul>
<li>这里提到了 PhoneStateListener，补充下好了。<del>按照官方说的使用 NONE 去注册就是反注册的意思，但实际并不会（试着用 LeakCanary检测下）。还是得使用 WeakReference。</del><ul>
<li>PhoneStateListener 的内存泄漏只会在使用匿名内部类的情况下出现。这种泄漏可通过将成员变量引用置空或使用静态内部类解决。</li>
</ul>
</li>
<li>提到了 AsyncTask：「这种内存泄漏一般是临时性的」。这种说法就没法接受了。AsyncTask 在主线程初始化，doInBackground 在线程池的线程执行，最后还会在主线程回调，只要 Task 还在执行必定不会放开主线程的引用，如果之前说到 Looper 的 message 算内存泄漏，AsyncTask 这种会被另外线程引用的不是更糟？再考虑如果在有 Activity 重建的场景下用 AsyncTask，内存泄漏会更严重。</li>
<li>「在应用中只要使用一次Webview，内存就不会被释放掉」喵喵喵？？？求来源，知道 WebView 是在另外一个线程且用 Activity 容易导致泄漏，可不释放是怎么回事，不是超严重的bug吗？</li>
</ul>
<p>3.4.4 内存泄漏监控</p>
<ul>
<li>「（LeakCanary）编译器技术会检测无操作指令并出于优化的目的将无操作指令剔除」，releaseCompile 跟 testCompile 就是引用了一个相同方法名，但是方法实现为空的库而已。可是为什么我看不懂作者在说什么呢= =</li>
</ul>
<p>3.5.4 图片内存优化</p>
<ul>
<li>「如inSampleSize为2时获得只有1/2大小的图片」，inSampleSize 是长度取样比例，2的话，图片大小是4分之一，因为长宽各除于2= =</li>
<li>「而Android 4.4之后可以（使用inBitmap）重用任何bitmap的内存区域」：前提是这些 bitmap 都是 mutable 的：<a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">inBitmap</a>    <ul>
<li>另外，参考后面写的图片库，BitmapFactory.decodeStream 方法没有传入任何 options，这时返回的图片默认是 immutable 的，也就是根本用不了 inBitmap = =</li>
</ul>
</li>
</ul>
<p>3.6.1</p>
<ul>
<li>「所以增加了volatile关键字，用来保证MiniImageLoader对象只在主内存中加载。」，volatile 的语义有限制到这种地步吗。参照周志明的《深入理解Java虚拟机》，volatile的语义有 1：保证变量对所有线程的可见性；2:禁止指令重排序（不大清楚因为改成dex指令后Dalvik有没有实现二）。volatile只是保证了实例初始化之后其他线程不会再进入最后的null代码块而已。</li>
</ul>
<p>3.6.2</p>
<ul>
<li>「Fresco，UIL等，都使用了“内存-本地-网络”三级缓存策略」：真的特别想问网络在什么时候成为客户端缓存了，而且还是常识？面过的人都跟我说缓存有三级。在网上搜 three level cache，基本没搜到有用的内容。Fresco 是提到了它们用三级缓存，但他们是「内存两层（应用内存，匿名共享内存），文件一层」啊。<ul>
<li>后面推荐了 UniversalImageLoader，随便提下，明明是17年还推荐这个有点过分了（。Glide更好，UIL 15年就停止更新了。</li>
</ul>
</li>
</ul>
<p>6.3 JobScheduler</p>
<ul>
<li>【出现了ThreadHandler= =还有其他很多奇怪的单词拼错了，是不是翻译的时候错了。</li>
<li>这里说 JobSchedulerService 要实现两个方法，后面突然冒出个 <code>jobFinished()</code> 这第三个方法也是神奇了= =</li>
<li>JobScheduler（6.3.3.1）不少内容来自于这里，照着翻译的（中文夹杂了个「and」，这是漏翻了吧：D）：<a href="https://code.tutsplus.com/tutorials/using-the-jobscheduler-api-on-android-lollipop--cms-23562" target="_blank" rel="external">JobScheduler</a> ，官方文档也有一部分（ThreadHandler 也是因为翻译的时候少了一个斜杆导致的吧：<a href="https://developer.android.com/reference/android/app/job/JobService.html" target="_blank" rel="external">JobService</a></li>
</ul>
<p>6.4 Doze</p>
<ul>
<li>书里说是两个条件，但官方说的是「如果用户设备未插接电源、处于静止状态一段时间且屏幕关闭，设备会进入低电耗模式」，这是三个条件= =</li>
<li>其他大概都是官方文档级别的说明。并没有多少实践。基本上所有把 targetSDK 设置得特别低的都不会使用这些内容吧= =</li>
</ul>
<p>7.1</p>
<ul>
<li>「lib下可以包含4种类型」。唔，说是可以，好像也没错- -反正官方举的例子有这些「armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, mips.」。之后还有可能会增加，看厂商？</li>
</ul>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>17.5.9 </p>
<ul>
<li>修正 PhoneState 内存泄漏的说明。</li>
<li>修正 mark-copy 的说法。copy 算法是将存活对象直接拷贝到另外分区（就是Survivor）的做法，不需要标记。</li>
</ul>
<p>17.5.11</p>
<ul>
<li>修正「并发GC」这种说法。这是不存在的= =</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;有好长一段时间没留意过（快有一年了说不定）市面上 Android 相关的开发书籍了。前几天面试完的时候领导突然让我给他推荐几本 android 开发相关的「好书」，我才又去亚马逊翻了一下排行榜。&lt;br&gt;《Android应用性能优化最佳实践》这本书给我留下了一点印象，作者好像很厉害，T家音乐的十年总监，评价也都是五星。唔，看起来不错，只是没看过不好评价。晚上写清单给领导的时候他竟然刚好也提到了这本书，这么多人推荐，大概不是雷，速度买了电子版晚上回去看。&lt;/p&gt;
&lt;p&gt;结果还是踩到雷了= =&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="android" scheme="https://brainku.github.io/tags/android/"/>
    
      <category term="吐槽" scheme="https://brainku.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>《调试九法：软硬件错误的排查之道》</title>
    <link href="https://brainku.github.io/2016/12/11/debugging-the-9-rules/"/>
    <id>https://brainku.github.io/2016/12/11/debugging-the-9-rules/</id>
    <published>2016-12-11T00:25:14.000Z</published>
    <updated>2017-05-17T13:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><blockquote>
<p>当你发现你在随便改东西的时候，你要注意你又是在「猜测」而不是「观察」。 </p>
</blockquote>
<a id="more"></a>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h4><ul>
<li>如果找一个 bug 花费了大量的时间，那有可能是忽略了某个最基本的、最重要的规则。</li>
<li>下述提到的规则都是你要「记住并应用」的。</li>
<li>这本书始终围绕着「查找 bug 的根源并修复」这个重点。</li>
</ul>
<h4 id="2-总体规则"><a href="#2-总体规则" class="headerlink" title="2 总体规则"></a>2 总体规则</h4><ul>
<li>就是 3-11 这几个小点。</li>
</ul>
<h4 id="3-理解系统"><a href="#3-理解系统" class="headerlink" title="3 理解系统"></a>3 理解系统</h4><ul>
<li>阅读手册—仔细阅读每个细节。出现问题的时候，重新回来查阅，几乎没人能仅靠一次阅读就记住所有细节。</li>
<li>掌握基础知识：只有知道什么是正常的才能区分不正常。</li>
<li>了解工作流程、原理和你使用的工具。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方。</li>
</ul>
<h4 id="4-制造失败"><a href="#4-制造失败" class="headerlink" title="4 制造失败"></a>4 制造失败</h4><ul>
<li>制造失败，试着让它再次发生。理由：a 观察 b 查找线索 c 确认是否修复。引发失败的时候，使这个过程自动化会非常有帮助。</li>
<li>不要模拟失败：两者使用了不同的环境，可能错误的方式都不一样。</li>
<li>对于间歇性失败，查找不受你控制的条件，记录它，找到它的特征。</li>
<li>如果 bug 发生了，那就没有「不可能」，因为它就是出现了。别怀疑「另一种口味的冰淇淋」就是原因。</li>
<li>别丢掉你的调试工具：你为了解决问题造出来的轮子哪天会再派上用场也不定。</li>
</ul>
<h4 id="5-不要想，而要看"><a href="#5-不要想，而要看" class="headerlink" title="5 不要想，而要看"></a>5 不要想，而要看</h4><ul>
<li>观察失败，查看细节：直到你能确定错误的大致可能。猜测只为确定观察的重点。</li>
<li>利用各种工具提供「观察」足够的信息————同时注意工具的影响。</li>
</ul>
<h4 id="6-分而治之"><a href="#6-分而治之" class="headerlink" title="6 分而治之"></a>6 分而治之</h4><ul>
<li>逐次逼近缩小范围，这需要具备的两个条件：1. 确定范围  2. 确定问题出在哪一侧，从这一侧开始</li>
<li>使用易于观察的输入或输出（测试模式）</li>
<li>修复已知bug（bug间会相互吸引），排除噪音干扰（调试不是你该重构的时候！）</li>
</ul>
<h4 id="7-一次只改一个地方"><a href="#7-一次只改一个地方" class="headerlink" title="7 一次只改一个地方"></a>7 一次只改一个地方</h4><ul>
<li>控制变量，一次只改一个地方，如果没修复，先还原。</li>
<li>在知道发生什么之前先握住黄铜杆，别乱动系统。【我总是忍不住猜测，修改，编译代码，这也许才是最费时的。</li>
<li>找到出问题前的最后一个版本，确定这之后修改了什么。</li>
</ul>
<h4 id="8-保持审计跟踪"><a href="#8-保持审计跟踪" class="headerlink" title="8 保持审计跟踪"></a>8 保持审计跟踪</h4><ul>
<li>记录你的操作、操作顺序和结果记录下来。关联几个维度上的事件，哪个事件的哪个行为持续了多久。</li>
<li>注意「任何」细节（或者说像是「格子衬衫」这样的共同的细节）</li>
<li>充分利用版本控制系统。</li>
<li>如果你知道会有什么问题，事先就加上注释解释下。这对你跟后来的维护者都好。</li>
</ul>
<h4 id="9-检查插头"><a href="#9-检查插头" class="headerlink" title="9 检查插头"></a>9 检查插头</h4><ul>
<li>质疑你的假设（深信不疑是真理的可怕敌人，甚至比谎言更为可怕），当你排除了所有的不可能，剩下就是原因。<ul>
<li>运行不正确的时候，你得先怀疑你的修改生效了吗。</li>
</ul>
</li>
<li>从头开始：系统是不是从第一步开始按照预定的顺序执行了</li>
<li>怀疑你的工具：想起了可爱的 AS，这个经常坑人的工具，InstantRun 刚出来就满满的一堆坑。</li>
</ul>
<h4 id="10-获得全新观点"><a href="#10-获得全新观点" class="headerlink" title="10 获得全新观点"></a>10 获得全新观点</h4><ul>
<li>放下面子，征求别人的意见，听取别人的经验。（你的目标是什么？解决问题才是你最该关心的事）</li>
<li>对于非自己的专业领域，从专业人士获取意见更快。</li>
<li>总是描述症状而不是你的理论，别人对你的询问也同理。任何确定可疑的地方都可以提出来（就算是格子衬衫） </li>
</ul>
<h4 id="11-如果你不修复-bug，它将依然存在"><a href="#11-如果你不修复-bug，它将依然存在" class="headerlink" title="11 如果你不修复 bug，它将依然存在"></a>11 如果你不修复 bug，它将依然存在</h4><ul>
<li>查证是「你的方案」确实修复了问题：去掉你的方案是否能够复现问题？</li>
<li>bug 从不会消失，你能做的是在 bug 发生的时候记录足够的信息来让你复现：<ul>
<li>(想到最新的免费票活动，有些人总会发送失败，我加了两次失败的日志。第一次是只加了本地的日志记录，没有写入文件。第二次是加了日志，但日志信息并不足够详细，我根本没法根据这些信息复现场景。)</li>
</ul>
</li>
<li>不要只对结果进行修复，修复整个过程，或者说要从根本上解决问题。</li>
</ul>
<h4 id="12-一个案例"><a href="#12-一个案例" class="headerlink" title="12 一个案例"></a>12 一个案例</h4><ul>
<li>通过一个案例讲述所有规则（偏向硬件，但涉及到了上述的这些规则）</li>
</ul>
<h4 id="13-牛刀小试"><a href="#13-牛刀小试" class="headerlink" title="13 牛刀小试"></a>13 牛刀小试</h4><ul>
<li>有个地方很有趣：两条线路，第一条「看起来」正常，第二条一直异常。在修复了第二条的问题之后，将类似的结论运用到第一条之后，会发现它不应该正常。把第一条线路检查之后才发现某些情况它才能正常。—这种「原本正常」的异常，我是不是在哪里遇到过？</li>
</ul>
<h4 id="14-帮助台"><a href="#14-帮助台" class="headerlink" title="14 帮助台"></a>14 帮助台</h4><ul>
<li>说到帮助台，一般都会认为是「远程支持」，「技术服务」这类工作才会遇到的场景，直到我想起了之前同事跟其他部门联调 SDK 时的事。只能在popo交流，只能通过发送特殊版本的插桩包进行日志的记录。所以这一章节可以在有真正遇到的时候再找来翻翻。</li>
<li>为维修记录提供数据库—这个感觉不错，即时不用于查询，平时翻阅一下也不错，防止和其他人一样犯同样的错误。</li>
<li>遵循规则，对行动和结果进行确认—即使是最简单的假设也得确认。</li>
<li>使用自动工具，使用可用的故障维修指南—可以的话并试着完善。</li>
</ul>
<h3 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h3><blockquote>
<p>如果查找一个bug花费了大量时间，那么原因可能是忽略了某个最基本的、最重要的规则。关键是记住并应用这些规则。</p>
</blockquote>
<p>书里最重要的一段话。整本书主要都在介绍这些规则。</p>
<blockquote>
<p>你必须掌握系统的工作原理以及它是如何设计的。在某些情况下，还要知道为什么这样设计。如果你没有理解系统中的某个部分，那么这通常就是出问题的地方……<br>如果你想要查明系统为什么不工作的话，必须先理解它的工作原理。</p>
</blockquote>
<ul>
<li>想起之前遇到的各个问题，比如我现在仍然搞不懂<ol>
<li>「RecyclerView设置了 wrap_content 之后，跟 PullToRefresh合作的时候会发生先居中再跳的问题」</li>
<li>「为什么从横屏切回竖屏的时候 PullToRefresh 会先拉到低，再闪回去」</li>
</ol>
</li>
</ul>
<p>这些问题都可以归因为我不知道「为什么这样子能干活？为什么 RecyclerView 实现一个 wrap_content 对现有的布局改动那么大」。这样的问题我都没去弄懂，为什么我会有自信去解决其他问题呢？<br>解决问题而不带入其他问题，这需要你真的理解系统。</p>
<blockquote>
<p>原来的工程师在设计电路时没有查阅引脚的编号以确保连接正确。随后，Kneejerk使问题进一步复杂化，他没有通过理解电路来查明为什么新元件会发热</p>
</blockquote>
<ul>
<li>我是不是经常干这种不知道为什么但是就是能干活，就是不要这么干的事。搞清楚啊，这是你需要弄懂的东西。</li>
</ul>
<blockquote>
<p>失败的确发生了。我们并不清楚是什么测试序列触发了它，也不知道它是由什么bug引起的。那么，下一步就是忘掉所有假设，让它在工程师面前再次发生</p>
</blockquote>
<ul>
<li>想到了之前的场景，可是现在这种情况要蛋疼得多，因为是设备限定的，我怎么排除不是硬件设备导致的呢？我总是归罪于硬件差异。</li>
</ul>
<blockquote>
<p>一直观察，直到把问题的原因锁定在几种可能性之内。<br>…<br>在调试时应该查找一些什么信息呢？你所选择的那部分内容应该能够证实你的判断，或者显示出你未意料到的行为（正是这些行为导致了bug）。<br>…<br>如果做了一个改变后看上去没有什么效果，应立即把它改回来。<br>…<br>找出第一个导致系统出错的版本。</p>
</blockquote>
<ul>
<li>这个经常做？因为改动太大，我找到对应的那个版本并回滚。我大概掌握了这个技能。</li>
</ul>
<blockquote>
<p>发现当视频压缩器尝试处理极难压缩的图案（活动着的格子衬衫）时，它就会停止工作（参见图8-1）。</p>
</blockquote>
<p>这个跟之前看过的几个经典例子同样有趣。</p>
<blockquote>
<p>永远不要相信自己的假设，特别是当这些假设在一些无法解释的问题中是核心因素的时候…系统是否运行了你要运行的代码？ </p>
</blockquote>
<ul>
<li>说到假设，突然想起预先设定的输入类型。你没法保证输入数据的类型。</li>
</ul>
<blockquote>
<p>当所有其他方法都失败时，再次阅读手册。<br><br>如果你获取了正确的见解、专业知识和经验，将会更快地修复问题。这并不会暴露你的弱点，如果说有什么的话，也只是说明你明智地选择了帮助。<br><br>在向别人描述问题的时候，一定要记住一件事：报告症状，而不要讲你的理论。之所以要从别人那里获得全新的观点，就是因为你的理论起不到任何作用</p>
</blockquote>
<p>这跟之前看到的如何提问那本书一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当你发现你在随便改东西的时候，你要注意你又是在「猜测」而不是「观察」。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="实用向" scheme="https://brainku.github.io/tags/%E5%AE%9E%E7%94%A8%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>读《代码整洁之道》</title>
    <link href="https://brainku.github.io/2016/08/10/read-clean-code/"/>
    <id>https://brainku.github.io/2016/08/10/read-clean-code/</id>
    <published>2016-08-10T15:03:00.000Z</published>
    <updated>2017-05-17T13:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>无关的前言。六月时买的书，一直藏着没打算看。把深入理解 Android 卷III 翻完之后就决定把这本书翻了。</p>
<a id="more"></a>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>作为一本指导类型的书，这本书讲了从变量名一直到多线程同步编程，系统设计，涵盖了各种细节到大观。  </p>
<p>说结论，我个人并不是很喜欢这本书。相较于程序员修炼之道，这本书有大量主观的说法。  </p>
<hr>
<p>关于命名，我非常赞同作者的说法。在项目里我见过太多名字被起得莫名其妙的类，域名，方法。这些类根本让人无法搜索，只能通过入口去一层一层深入。这真的是一件让人很恼火的事。<br>作者也把匈牙利命名法批判了一番，这种前缀毫无意义。前缀跟后缀应该使用来表示 Context，而非用于标记这是一个变量或者其他。</p>
<hr>
<p>关于方法，我赞同有些方法应该尽可能地短，函数名应该尽可能表达其含义。但我在书里所看到的是，不少是支离破碎的细节。确实，尽可能地提取了函数之后，逻辑上会更加清晰，但跳转逻辑太多也会让人恼火。我更习惯于在逻辑快变得复杂时，将这一部分单独提取出来。把每个 if 语句的判断逻辑都写成一个函数，我应该也没有这种重构的时间。<br>另外，作者偶尔也会自我矛盾。有时候他提取了小逻辑，有时候他又说这没必要。这其中并没有一个标准。  </p>
<hr>
<p>关于注释，「注释最多只是一种必须的恶」。因为你没法用你的函数名清楚地告诉调用者使用之后会发生什么事，所以你要说明。<br>作者提到的是否需要注释的部分，有些只能算是说说罢了。比如说，公共使用的 API 需要注释。你并没法保证你做的这个模块是否会成为公共模块，所以你到底要不要写注释呢？<br>关于糟糕的注释也是，修炼之道告诉你，你要署名，因为这代表是你所完成的，代表你对这份代码负责。这本书告诉你：署名？丢掉吧，版本控制系统会告诉你。但我个人倾向于修炼之道的做法。   </p>
<hr>
<p>「<strong>一组开发者应当认同同一种格式风格，每个成员都应该采用那种风格。</strong>」这句话真的是戳到了我的痛点，我在跟一群完全不在乎这种事的人共事着。连格式都不在乎，他们怎能写出让人愉快的代码？</p>
<hr>
<p>书里关于异常处理的代码，确实是让我看到异常的另外一种处理方法。将内部抛出的各类异常包裹成自己的异常，使内部的代码尽可能地简洁，即 try 块中只有正常执行的代码。这种代码看起来真的蛮舒服的，值得一试。</p>
<hr>
<p>这本书后半很大一部分的内容都是作者在教你怎么把一段看起来不怎么「优雅」的代码改成<strong>他想要的样子</strong>。书的最后更是贴了六十几页的代码来举一个完整的例子。<br>可是我在他改的过程中所看到很多是作者自己主观的想法。一个函数到底多短才可以？这真的不只是越短越好。hot point 的话，方法内联也是必须的。如果你知道一个函数会把大量调用，适当减少调用层次会帮你不少忙。另外，时间跟效率的平衡也是值得考虑的一件事。我真没空把函数拆得支离破碎，在保证「一定」整洁性的前提下，我得去干其他事。</p>
<hr>
<p>书里提到的大量重构的内容，我觉得我大概怎么都做不了吧。Android 真不是一个希望你能给你的应用写测试的平台。</p>
<h3 id="另外一件事"><a href="#另外一件事" class="headerlink" title="另外一件事"></a>另外一件事</h3><p>这是一部译著，这本书需要评论还有它的翻译。<br>我想，如果当初我是在实体书店翻过这本书的话，我是一定不会买的吧。这个翻译翻出来的文字读起来让人特别纠结，文诌诌的（比如把依赖翻成依恋），完全没有作者在某些地方表现出来的幽默感。最可怕的是，这个译者有些专业术语更是不可原谅地翻错了。explaining temporary variables - 解释临时变量模式？what？具有解释性的临时变量多正常。把 decorator 翻成油漆工？把 collection 翻成集群类？真怀疑译者到底有没有起码看过一本设计模式书籍或者Java入门书。</p>
<h3 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h3><p>如果要给这本书一个评分的吧，就像我在豆瓣上给的，原书4分，翻译2分。这个翻译太糟糕，列入黑名单。<br>在豆瓣上给的评价：</p>
<blockquote>
<p>「4分给原作，翻译2分。整本书看起来极其费力。译者好像在追求着用语的与众不同，比如把依赖翻成依恋？译者的辞藻是不是用错地方了。看霍炬翻的重构我都没有这种感觉，人家是翻得是真有文采跟幽默感。这本书最糟糕的是把一些专业术语翻得莫名其妙，把装饰器翻成油漆工？集合类翻成集群类。任何一个看过设计模式跟Java入门书的人都不会这么翻。」</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;无关的前言。六月时买的书，一直藏着没打算看。把深入理解 Android 卷III 翻完之后就决定把这本书翻了。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="工程实践" scheme="https://brainku.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Python的快速入门--《A Byte of Python》</title>
    <link href="https://brainku.github.io/2014/10/14/learn-python-in-a-quick-way/"/>
    <id>https://brainku.github.io/2014/10/14/learn-python-in-a-quick-way/</id>
    <published>2014-10-14T06:57:46.000Z</published>
    <updated>2016-08-20T12:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>虽然这本书说适合没有太多编程基础的人，但我这篇总结是为具有一定编程基础的人所准备的- -<br>书中一开始先简单介绍了python的一些基本语法规则，标识符，接着按章节以‘<strong>操作符与表达式</strong>’，‘<strong>控制流</strong>’，‘<strong>函数</strong>’，‘<strong>模块</strong>’，‘<strong>数据结构</strong>’，‘<strong>OOP</strong>’，‘<strong>输入和输出</strong>’，‘<strong>异常</strong>’及‘<strong>其他拓展</strong>’的顺序较为完整地介绍了python的主要内容。<br><a id="more"></a></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>python只有int，没有long。int但可以表达任意的大小</li>
<li>单引号效果跟双引号类似。但两组三引号之间可以有任意行的内容。(常用于模块或类说明内容）</li>
<li><code>format()</code>是个好方法。</li>
<li>python的缩进非常非常重要，一旦搞错就有可能报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding=utf-8 </span></div><div class="line"><span class="keyword">print</span> (<span class="string">"&#123;0:*^9&#125;"</span>.format(<span class="string">'hello'</span>))     <span class="comment"># 将format的内容用^前的符号填充到指定长度</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"&#123;0:.3f&#125;"</span>.format(<span class="number">1</span>/<span class="number">3.0</span>))       <span class="comment"># 取小数点后三位输出</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"value %r %d"</span> % (<span class="number">10</span>, <span class="number">10</span>))      <span class="comment"># r for everthing</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"value &#123;&#125; &#123;&#125;"</span>.format(<span class="number">10</span>, <span class="number">10</span>))</div><div class="line"><span class="keyword">print</span> (<span class="string">"value"</span>, <span class="string">"&#123;&#125;"</span>.format(<span class="number">10</span>))      <span class="comment"># ','相当于空一格</span></div><div class="line"><span class="keyword">print</span> (<span class="string">r"raw_string\n"</span>)               <span class="comment"># 加上r表示不发生任何转义,适用于正则</span></div><div class="line"><span class="string">"""</span></div><div class="line">**hello**</div><div class="line">0.333</div><div class="line">...</div><div class="line">raw_string\n</div><div class="line">"""</div></pre></td></tr></table></figure>
<h3 id="操作符与表达式"><a href="#操作符与表达式" class="headerlink" title="操作符与表达式"></a>操作符与表达式</h3><ul>
<li>除了其他语言常见的操作符及用法，python还有自己独特的地方</li>
<li><code>*</code>可用于一个数字与一个字符串，用于复制相同的字符串n遍</li>
<li><code>**</code>用于计算幂</li>
<li><code>not</code>用于取反  【SELF】：注意bool是int的子类= =所以0是<code>False</code></li>
<li><code>and</code>用于与操作，支持短路求值</li>
<li><code>or</code>用于或操作，支持短路求值</li>
<li>赋值具有右结合性：<code>a=b=c</code>即<code>a=(b=c)</code></li>
<li>不支持自增自减符号。<code>--a</code>只代表取反两次，<code>a--</code>直接报错</li>
</ul>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line">isRight = <span class="keyword">False</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> isRight:</div><div class="line">    value = int(raw_input(<span class="string">"input value:"</span>))</div><div class="line">    <span class="keyword">if</span> value == <span class="number">3</span> : isRight = <span class="keyword">True</span></div><div class="line">    <span class="keyword">elif</span> value &lt; <span class="number">3</span>: <span class="keyword">print</span> <span class="string">"larger"</span></div><div class="line">    <span class="keyword">else</span>: <span class="keyword">print</span> <span class="string">"smaller"</span>           <span class="comment"># else跟冒号间不能加任何内容</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"Guess Right"</span>)</div></pre></td></tr></table></figure></p>
<p>循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># while的例子上方有</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>): <span class="comment"># 1 2 3 4</span></div><div class="line">    <span class="keyword">print</span> i,</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>): <span class="comment"># 1 3 第三个参数控制步长</span></div><div class="line">    <span class="keyword">print</span> i,</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]: <span class="comment"># 1 2 3 4 5</span></div><div class="line">    <span class="keyword">print</span> i,</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">1</span>, <span class="number">5</span>)):</div><div class="line">    <span class="keyword">print</span> i,</div><div class="line"><span class="comment"># 其他break和continue的控制流语句类似</span></div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>局部和全局变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line">x = <span class="number">50</span></div><div class="line"><span class="comment"># 没有引入全局变量x，引用的是局部变量</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_local</span><span class="params">(x, value)</span>:</span></div><div class="line">    <span class="keyword">print</span> x      <span class="comment"># 50</span></div><div class="line">    x = value</div><div class="line"><span class="comment"># 全局变量需要先声明再使用，否则有warning: name 'x' is used prior to global declaration</span></div><div class="line"><span class="comment"># 无法定义 global x = 2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_global</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">global</span> x</div><div class="line">    <span class="keyword">print</span> x      <span class="comment"># 50</span></div><div class="line">    x = value</div><div class="line">func_local(x, <span class="number">2</span>) <span class="comment"># 50</span></div><div class="line"><span class="keyword">print</span> x          <span class="comment"># 50</span></div><div class="line">func_global(<span class="number">2</span>)   <span class="comment"># 50</span></div><div class="line"><span class="keyword">print</span> x <span class="comment"># 2      # 2</span></div></pre></td></tr></table></figure></p>
<p>默认参数值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 默认参数只能是参数列表的最后一个或最后几个参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callHello</span><span class="params">(content, times = <span class="number">1</span>)</span>:</span></div><div class="line">    <span class="keyword">print</span> (times*content)</div><div class="line">callHello(<span class="string">"hello"</span>)  <span class="comment"># hello</span></div></pre></td></tr></table></figure></p>
<p>关键字参数(Keyword Arguments)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 仍然是默认参数值，只是调用函数时的一种技巧</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callHelloTo</span><span class="params">(content, someone=<span class="string">"you"</span>, user = <span class="string">"I"</span>)</span>:</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">"&#123;&#125; say &#123;&#125; to &#123;&#125;"</span>.format(user, content, someone))</div><div class="line">callHelloTo(someone=<span class="string">"Brain"</span>, content=<span class="string">"Nice to Meet you"</span>)</div><div class="line"><span class="comment"># I say Nice to Meet you to Brain</span></div></pre></td></tr></table></figure></p>
<p>变长参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># numbers是list，而kcount是dictionary</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calsum</span><span class="params">(init = <span class="number">0</span>, *numbers, **kcount)</span>:</span></div><div class="line">    <span class="string">'''cal input value sum'''</span></div><div class="line">    result = init</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> numbers:</div><div class="line">        result += value</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> kcount:</div><div class="line">        result += kcount[key]</div><div class="line">    <span class="keyword">print</span> (<span class="string">"result is &#123;&#125;"</span>.format(result))</div><div class="line">calsum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,d=<span class="number">-15</span>) <span class="comment"># result is 0</span></div></pre></td></tr></table></figure></p>
<p>return语句</p>
<ul>
<li>如果没有写return语句，默认是返回<code>None</code></li>
</ul>
<p>DocStrings</p>
<ul>
<li>python的注释文档，即在函数体/模块/类的首行三引号间的内容。</li>
<li>可以通过<code>print xx.__doc__</code>或<code>help(xx)</code>输出</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>模块即可复用的部分。 </li>
<li>最简单的是直接写一个py文件，直接<code>import</code>导入</li>
<li>也可使用编译后的pyc文件（字节码形式，而非机器码，因而是平台无关）</li>
<li>可通过<code>__name__</code>获取模块名称。常用<code>__name__==&#39;__main__</code>判断是否主模块。</li>
<li>导入时也可使用<code>from ... import ...</code>,只是不建议，可能命名冲突。</li>
<li>也可使用<code>from ... import *</code>的形式导入所有公有域和公有方法 </li>
<li>定义一个通用的module通常需要遵守一些公有约定，比如私有域中包含版本信息，作者信息等。</li>
<li>可以通过<code>dir()</code>方法获取模块所有域的信息。括号中不包含模块即代表查询本模块。</li>
<li>package是module的集合。在每个模块的同级目录下都有一个__init__.py文件说明模块信息</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Python内置四种数据结构，list，tuples，dictionary，set。  </p>
<ul>
<li>list是可变的，即列表元素可增删，排序等</li>
<li>tuple是不可变的，在初始化之后即不可再改动</li>
<li>dictionary是key-value，添加时不能保证有序。key必须为不可变对象</li>
<li>set是简单对象的无序序列，可用于集合操作（set自身提供了大量集合操作）</li>
</ul>
<p>关于sequence</p>
<ul>
<li>list，tuple，string都是sequence，都支持集合操作（比如<code>in</code>和<code>not in</code>等），另外也支持下标取值。下标可以为负值，代表逆方向取值。</li>
<li>sequence也支持slicing操作，即<code>[:]</code>和<code>[::]</code>。通过该操作返回的是原sequence的一个拷贝。可以通过<code>[::-1]</code>轻易获得一个逆序。</li>
</ul>
<p>关于引用</p>
<ul>
<li>同样存在别名现象，所以如果需要复制数组，可以使用slicing（即<code>[:]</code>)</li>
</ul>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><ul>
<li>method和field是class的attribute，两者均有实例和类两种范围。</li>
<li>类的每个实例方法的第一个参数都是self，即自身。可以理解成是Java和C++中的this。【作者给出的是这种说法真有趣，事实是否真的如此？:<code>myobj.method()=&gt;MyObj.method(myobj)</code>】</li>
<li>构造器：<code>__init__(self,...)</code>。如果存在基类，则先调用基类的初始化函数</li>
<li>类方法和静态方法看做是Python decorator的使用</li>
<li>Python中类所有的method和field都是virtual的</li>
<li>继承，所有基类的构造函数都需要自己调用</li>
</ul>
<p>一个完整的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="string">'''A person is the base of everyone'''</span></div><div class="line">    count = <span class="number">0</span>                 <span class="comment"># 类变量在外部声明</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        Person.count += <span class="number">1</span>     <span class="comment"># 使用时使用类引用变量</span></div><div class="line"><span class="meta">    @classmethod              # 也可以用staticmethod，但调用时再传入类名。</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCount</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"Total: &#123;&#125;"</span>.format(cls.count))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'''Show person info'''</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"Name is &#123;&#125;"</span>.format(self.name))</div><div class="line"><span class="comment"># Python也支持多重继承，只需要在声明时增加类即可</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, school)</span>:</span></div><div class="line">        Person.__init__(self, name) <span class="comment"># 先调用基类初始化。没有super关键字</span></div><div class="line">        self.school = school</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self)</span>:</span></div><div class="line">        Person.call(self)           <span class="comment"># 调用基类方法时也需要传入self</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"&#123;&#125;'s shool is &#123;&#125;"</span>.format(self.name, self.school))</div></pre></td></tr></table></figure></p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><code>raw_input()</code>用于获取用户输入</li>
<li><code>open(&quot;file&quot;, [options])</code>操作用于读写文件。file的<code>read()</code>,<code>readline()</code>等操作可以用于读行的内容。</li>
<li><code>Pickle</code>这个module可将python的对象保存到文件中。只需要使用<code>pickle.dump(data, file)</code>和<code>pickle.load(file)</code>操作~</li>
<li>对于unicode字符，需要使用<code>encoding=&quot;utf-8&quot;</code></li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>使用<code>try...except...</code>捕获异常</li>
<li>使用<code>try...finally...</code>保证即使发生异常也能够好好收拾残局–&gt;更加推荐的方式是<code>with...as...</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortLengthException</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, content)</span>:</span></div><div class="line">        Exception.__init__(self)</div><div class="line">        self.content = content</div><div class="line">        self.length = length</div><div class="line"></div><div class="line">    value = raw_input(<span class="string">"Input--&gt;"</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">if</span> len(value) &lt; <span class="number">3</span>:</div><div class="line">        <span class="keyword">raise</span> ShortLengthException(len(value), value)</div><div class="line"><span class="keyword">except</span> EOFError:</div><div class="line">    <span class="keyword">print</span> (<span class="string">"Not an EOF!"</span>)</div><div class="line"><span class="keyword">except</span> ShortLengthException <span class="keyword">as</span> ex:</div><div class="line">    <span class="keyword">print</span> (<span class="string">"exception: &#123;&#125; 's length &#123;&#125; is to short"</span>\</div><div class="line">	   .format(ex.content, ex.length))</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> (<span class="string">"nice length"</span>)</div></pre></td></tr></table></figure>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li><p><strong>Passing tuples around</strong>:可将tuples整个作为返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_error_detail</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> (<span class="number">2</span>, <span class="string">"error"</span>)</div><div class="line">errnum, errstr = get_error_detail()</div><div class="line"><span class="comment"># 最快的交换方式-Why can: 后面的参数先被创建为一个tuple再进行赋值</span></div><div class="line">a, b = b, a</div></pre></td></tr></table></figure>
</li>
<li><p><strong> Special method</strong>：除了<code>__init__()</code>这个方法外，还有其他类似的内置函数可用于增强功能。如实现<code>__getitem__()</code>即可实现任意对象下标取值。其他还有<code>__str__()</code>，<code>__len__()</code>等等…</p>
</li>
<li><strong>Single Statement Blocks</strong>：<code>if True: print (&quot;Nice&quot;)</code></li>
<li><strong>Lambda Forms</strong>：（讲得不大清楚= =)</li>
<li><p><strong>List Comprehension</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c = list(range(<span class="number">1</span>, <span class="number">100</span>))</div><div class="line">result = [i <span class="keyword">for</span> i <span class="keyword">in</span> c <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> i % <span class="number">9</span> == <span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> result <span class="comment"># 100以内所有能被2或9整除的数</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>Tubles and dictionaries as arguments</strong>：前面已使用</p>
</li>
<li><strong>Assert statement</strong>：并不少见</li>
<li><strong>Decorators</strong>：仍然解释不清楚</li>
</ul>
<h3 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h3><ul>
<li>lambda表达式是怎么回事= =</li>
<li>Python的decorators到底是什么</li>
</ul>
<h2 id="正文无关："><a href="#正文无关：" class="headerlink" title="正文无关："></a>正文无关：</h2><h3 id="为什么选这本书"><a href="#为什么选这本书" class="headerlink" title="为什么选这本书"></a>为什么选这本书</h3><p>前几天一直在网上看<em>《Learn Python In A Hard Way》</em>的在线教程，效率实在是低—这书讲得真的是太慢了，每次都只教一点点零碎的这种学法不适合我。<br>我想要看的是那种能够快速了解语法，能够快速上手的书。而《A Byte of Python》非常地和我胃口，事实证明也是如此~<br>看完这本书之后，下一步的阅读计划就是<em>《Python Cookbook》</em>。这本Cookbook主要是一些代码片段，当然通常是很赞的技巧~看起来非常有趣，现在翻阅起来基本无障碍&gt;_&lt;~</p>
<h3 id="如何学习一门新语言"><a href="#如何学习一门新语言" class="headerlink" title="如何学习一门新语言"></a>如何学习一门新语言</h3><p>在我的书签中翻到这样的一篇博客<a href="http://www.yangzhiping.com/tech/learn-program-psychology.html" target="_blank" rel="external">“如何学习一门新的编程语言？——在学习区刻意练习”</a>。上面推荐了<em>《Learn XXX In Hard Way》</em>系列，作者认为带有大量习题的教程更加适合编程语言的入门。<br>而经过这次Python的学习，我个人并不赞同这种说法。作为一个有不少编程基础的非新人，接触一门新语言还需要从Rookie级别的书看起其实是费力不讨好的。<br>看了<em>《Learn Python In Hard Way》</em>的十几个Exercise，我还是停留在几个print语句上，累感不爱。而<em>《A Byte Of Python》</em>用了130页左右介绍了Python中的大部分内容，书的结构简单明了。知道这些90%的内容之后就可以干活了。实际使用的机会越多，越熟练，而不是做重复做那些习题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h3&gt;&lt;p&gt;虽然这本书说适合没有太多编程基础的人，但我这篇总结是为具有一定编程基础的人所准备的- -&lt;br&gt;书中一开始先简单介绍了python的一些基本语法规则，标识符，接着按章节以‘&lt;strong&gt;操作符与表达式&lt;/strong&gt;’，‘&lt;strong&gt;控制流&lt;/strong&gt;’，‘&lt;strong&gt;函数&lt;/strong&gt;’，‘&lt;strong&gt;模块&lt;/strong&gt;’，‘&lt;strong&gt;数据结构&lt;/strong&gt;’，‘&lt;strong&gt;OOP&lt;/strong&gt;’，‘&lt;strong&gt;输入和输出&lt;/strong&gt;’，‘&lt;strong&gt;异常&lt;/strong&gt;’及‘&lt;strong&gt;其他拓展&lt;/strong&gt;’的顺序较为完整地介绍了python的主要内容。&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="笔记" scheme="https://brainku.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="问题" scheme="https://brainku.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="python" scheme="https://brainku.github.io/tags/python/"/>
    
      <category term="入门" scheme="https://brainku.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="我的思考" scheme="https://brainku.github.io/tags/%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>关于onSaveInstanceState的那点事</title>
    <link href="https://brainku.github.io/2014/10/07/something-about-onsaveinstancestate/"/>
    <id>https://brainku.github.io/2014/10/07/something-about-onsaveinstancestate/</id>
    <published>2014-10-07T11:52:21.000Z</published>
    <updated>2017-05-09T23:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前对这个函数功能不是太了解，在<a href="https://brainku.github.io/2014/10/01/reading-android-develop-master/">阅读《Android开发精要》</a>这本书的过程中发现关于这个函数的描述存在矛盾。这个在Activity的生命周期中可能涉及到的函数做了什么，又是怎么做的，又有什么需要注意的，不弄懂的话说不过去~<br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>默认的情况下是怎么做的,先来看下官方的文档：</p>
<blockquote>
<p>默认实现是调用<code>View.onSaveInstanceState()</code>将大部分有指定id的View状态保存下来，如果存在focusedView也会保存对应的id信息。这些设置的信息都会在<code>onRestoreInstanceState()</code>的默认实现中恢复。如果你重写了这个方法来保存没被View保存的信息，记得调用<code>super</code>来调用默认实现，否则做好自己手动保存所有View状态的准备~(<strong>注：</strong>默认View是什么都不保存的，继承View的控件自己保存需要的内容</p>
</blockquote>
<p>官方是如此说明的，那么就跟踪一下代码如何？</p>
<h3 id="怎么做的"><a href="#怎么做的" class="headerlink" title="怎么做的"></a>怎么做的</h3><p>从Activity开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android/app/Activity.class</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">  <span class="comment">// 调用了Window保存层次信息，Window是一个抽象类，实现类是PhoneWindow</span></div><div class="line">  outState.putBundle(WINDOW_HIERARCHY_TAG,mWindow.saveHierarchyState());</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看看在Window的实现类里面做了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//com/android/internal/policy/impl/PhoneWindow.java</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bundle outState = <span class="keyword">new</span> Bundle();</div><div class="line">	<span class="comment">// 如果没有设置mContentParent,即它为null，则不需要保存任何信息直接返回</span></div><div class="line">	<span class="comment">// mContentParent为空的情况也就是没有调用installDecor的情况</span></div><div class="line">	<span class="comment">// 也即没有发生任何获取窗口的View以及设置添加View的行为,如setContentView</span></div><div class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> outState;</div><div class="line">        &#125;</div><div class="line">        SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">	<span class="comment">// 保存整个ViewGroup的层次信息</span></div><div class="line">        mContentParent.saveHierarchyState(states);</div><div class="line">        outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line">	<span class="comment">// 保存当前ViewGroup的focusedView</span></div><div class="line">        <span class="comment">// save the focused view id</span></div><div class="line">        View focusedView = mContentParent.findFocus();</div><div class="line">        <span class="keyword">if</span> (focusedView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (focusedView.getId() != View.NO_ID) &#123;</div><div class="line">                outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">		...<span class="comment">// log something</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	... <span class="comment">// save the panels</span></div><div class="line">	... <span class="comment">// save ActionBar state</span></div><div class="line">        <span class="keyword">return</span> outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里调用了<code>mContentParent.saveHierarchyState(states)</code>来保存整个ViewGroup的状态信息,其中<code>mContentParent = generateLayout(mDecor);</code>。如果有了解过Window的界面布局的话，会知道mContentParent其实也就是我们<code>setContentView()</code>时添加的布局。<br>再看看<code>mContentParent</code>做了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android/view.class</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">      dispatchSaveInstanceState(container);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">	<span class="comment">// 只有存在ID且允许保存状态的View才会被保存状态，否则忽略</span></div><div class="line">        <span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">            Parcelable state = onSaveInstanceState();</div><div class="line">	<span class="comment">// 继承类，如果没有调用super来保存父类的信息那么就抛出异常</span></div><div class="line">    	<span class="comment">// 这里有点小技巧，通过与操作取得了该设置位的信息</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        <span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">                container.put(mID, state);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mContentParent调用的<code>saveHierarchyState()</code>实际是View中实现的方法，而在ViewGroup只是重写了<code>dispatchSaveInstanceState()</code>这个方法来分发保存状态的事件到ChildView：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android/ViewGroup.class</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchSaveInstanceState(container);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        View c = children[i];</div><div class="line">        <span class="comment">// 如果ViewGroup没有设置不需要保存状态才保存ChildView</span></div><div class="line">        <span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本过程就是这样子，简单地总结下它怎么做的话就是<br><strong><em>onSaveInstanceState默认将调用当前Window中有id且有需要的View的onSaveInstanceState方法来保存它们自己所需要的信息</em></strong>（其实还会有保存fragment信息的过程，在这篇博客中暂不讨论~）</p>
<h3 id="存在哪里"><a href="#存在哪里" class="headerlink" title="存在哪里"></a>存在哪里</h3><p>做完上面那堆事之后，留有所有信息的那个outState又存到哪去了？<br>具体存储的过程可以在ActivityThread的源码中看到，它将这个bundle（也就是savedInstanceState）存储在了ActivityClientRecord这个类的实例中。<br>在《Android Programming》中提到的内容<strong>基本</strong>可信，因此这里不再跟踪源码。</p>
<blockquote>
<p>The bundle is then stuffed(被塞进）into your activity’s activity record by OS.</p>
</blockquote>
<p>那么这个record什么时候会被销毁？<br>如果你按下了返回键，那么Activity就被销毁了，对应的ActivityRecord也不复存在。另外在机器重启，或者这个Activity长期没再使用时，这个record也会被销毁。</p>
<h3 id="什么时候"><a href="#什么时候" class="headerlink" title="什么时候"></a>什么时候</h3><p>那么它又在什么时候调用的咧,看下API说明：</p>
<blockquote>
<p>为了能够在重新创建的某个时间点上来恢复它的状态，这个方法会在一个Activity可能被销毁前被调用。<br>不要跟Activity的生命周期如<code>onPause()</code>之类的回调中搞混。考虑下面三个场景</p>
<ol>
<li>onPause和onStop都被调用，但这个方法没被调用：从Activity B返回A，此时不会调用B的onSaveInstanceState方法，因为B不需要被恢复。</li>
<li>onPause被调用，但是onSaveInstanceState不被调用的情况：当B在A之后被创建，如果在B的生存期间A并没有被销毁的话，那么系统可能并不会调用A的onSaveInstanceState方法，因为这个时候的A仍然是完整的。</li>
</ol>
<p>如果这个方法会被调用，那么只能保证它会在onStop之前调用，无法保证它是在onPause之前还是之后被调用。</p>
</blockquote>
<p>在之前看过的资料中，《Android开发精要》中对于onSaveInstanceState的调用时机说明是有误的，它将这个方法的调用时间放在了<code>onPause()</code>之前。而按照上面的doc的说法，这个方法是否会被调用也还要看情况的，所以并不能依靠这个方法来保存数据。【实际在验证之后发现，在跳转的过程中该方法是一定会调用的，并未出现不调用的情况】</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在Activity的各个生命周期以及<code>onSaveInstanceState()</code>，<code>onRestoreInstanceState()</code>打log。验证一下在下面几种情况中，调用顺序的问题：</p>
<h3 id="旋转导致重建"><a href="#旋转导致重建" class="headerlink" title="旋转导致重建"></a>旋转导致重建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Rotation 4.4 以下均忽略一开始的onCreate到onResume</span></div><div class="line"><span class="number">10</span>-<span class="number">22</span> <span class="number">18</span>:<span class="number">50</span>:<span class="number">16.502</span>: D/Saved(<span class="number">1975</span>): <span class="function">call <span class="title">onPause</span><span class="params">()</span>             <span class="comment">// 发生旋转</span></span></div><div class="line">10-22 18:50:16.502: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onSaveInstanceState</span><span class="params">()</span></div><div class="line">10-22 18:50:16.502: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onStop</span><span class="params">()</span></div><div class="line">10-22 18:50:16.738: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onCreate</span><span class="params">()</span>            <span class="comment">// 重新创建</span></div><div class="line">10-22 18:50:16.742: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onStart</span><span class="params">()</span></div><div class="line">10-22 18:50:16.758: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onRestorInstanceState</span><span class="params">()</span></div><div class="line">10-22 18:50:16.758: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onResume</span><span class="params">()</span></div><div class="line"></div><div class="line"><span class="comment">//Rotation 2.3.7</span></div><div class="line">10-22 11:15:08.890: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onSaveInstanceState</span><span class="params">()</span> <span class="comment">// 发生旋转</span></div><div class="line">10-22 11:15:08.900: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onPause</span><span class="params">()</span></div><div class="line">10-22 11:15:08.910: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onStop</span><span class="params">()</span></div><div class="line">10-22 11:15:08.980: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onCreate</span><span class="params">()</span>            <span class="comment">// 重新创建</span></div><div class="line">10-22 11:15:09.010: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onStart</span><span class="params">()</span></div><div class="line">10-22 11:15:09.020: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onRestorInstanceState</span><span class="params">()</span></div><div class="line">10-22 11:15:09.030: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onResume</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>在查看ActivityThread源码的时候发现几句注释：</p>
<blockquote>
<p>We need to keep around the original state, in case we need to be created again.  But we only do this for pre-Honeycomb apps, which always save their state when pausing, so we can not have them save their state when restarting from a paused state.  For HC and later, we want to (and can) let the state be saved as the normal part of stopping the activity.</p>
</blockquote>
<p>在3.0之前，<code>onSaveInstanceState()</code>是<code>onPause()</code>的一部分，而在HC之后，则变成了<code>onStop()</code>的一部分。</p>
<h3 id="跳转恢复"><a href="#跳转恢复" class="headerlink" title="跳转恢复"></a>跳转恢复</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 4.4</span></div><div class="line"><span class="number">10</span>-<span class="number">22</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">49.253</span>: D/Saved(<span class="number">1975</span>): <span class="function">call <span class="title">onPause</span><span class="params">()</span></span></div><div class="line">10-22 18:51:50.321: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onSaveInstanceState</span><span class="params">()</span></div><div class="line">10-22 18:51:50.321: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onStop</span><span class="params">()</span></div><div class="line">10-22 18:53:12.772: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onStart</span><span class="params">()</span></div><div class="line">10-22 18:53:12.776: D/<span class="title">Saved</span><span class="params">(<span class="number">1975</span>)</span>: call <span class="title">onResume</span><span class="params">()</span></div><div class="line"><span class="comment">// 2.3.7</span></div><div class="line">10-22 11:15:55.680: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onSaveInstanceState</span><span class="params">()</span></div><div class="line">10-22 11:15:55.680: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onPause</span><span class="params">()</span></div><div class="line">10-22 11:15:56.380: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onStop</span><span class="params">()</span></div><div class="line">10-22 11:16:23.380: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onStart</span><span class="params">()</span></div><div class="line">10-22 11:16:23.380: D/<span class="title">Saved</span><span class="params">(<span class="number">1480</span>)</span>: call <span class="title">onResume</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>根据上面的log记录可以发现，就跟旋转导致重建的过程一样，因为同样的原因<code>onSaveInstancteState()</code>被提前了。</p>
<h3 id="按返回键退出"><a href="#按返回键退出" class="headerlink" title="按返回键退出"></a>按返回键退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>-<span class="number">22</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">03.100</span>: D/Saved(<span class="number">1588</span>): <span class="function">call <span class="title">onPause</span><span class="params">()</span></span></div><div class="line">10-22 11:37:03.980: D/<span class="title">Saved</span><span class="params">(<span class="number">1588</span>)</span>: call <span class="title">onStop</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>无论是否根Activity，都只会调用Activity的生命周期回调，而不会保存任何状态信息。再点开应用之后，也就无法恢复之前<code>onSaveInstanceState()</code>保存的数据。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于View的id"><a href="#关于View的id" class="headerlink" title="关于View的id"></a>关于View的id</h3><p>其实从mContentParent分发保存状态事件的过程中就可以发现，默认是使用ID来作为SparseArray的key的，那么就会存在无法保存状态或者状态异常的情况。</p>
<ol>
<li>没有设置ID</li>
<li>设置了同名id</li>
</ol>
<p>第一种情况基本不是问题，因为对于重要的控件一般都会设置一个id，但第二种情况就会比较麻烦了。设置同名id会导致后面出现的控件覆盖前面同名控件所保存的信息，而且还不会有任何警告。在查资料的过程中就发现了这样子的一个<a href="http://www.cnblogs.com/xiaoweiz/p/3813914.html" target="_blank" rel="external">例子</a>。</p>
<h3 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h3><p>这是跟<code>onSaveInstanceState</code>对应的方法，对应的实现过程就不再做分析（过程跟保存时的顺序相反），只谈谈这个方法调用的时机。<br>其实从上面验证的过程中就可以知道，<code>onRestoreInstanceState()</code>这个方法只在旋转重建的时候才被调用，在其他情况中均没有被调用。看下doc说明：</p>
<blockquote>
<p>这个方法在Activity在从之前保存的信息中（即savedInstanceState）重新恢复状态的时候，即在<code>onStart()</code>之后被调用。大多数实现会在onCreate中恢复它们的状态，但它有时候也很方便去做，当所有的初始化已经完成完成同时让子类去决定是否使用它们的默认实现。这个方法的默认实现会view恢复到之前被<code>onSaveInstanceState()</code>保存时的状态。<br>This method is called after onStart when the activity is being re-initialized from a previously saved state, given here in savedInstanceState. <strong>Most implementations will simply use onCreate to restore their state, but it is sometimes convenient to do it here after all of the initialization has been done or to allow subclasses to decide whether to use your default implementation.</strong> </p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>在验证<code>onSaveInstanceState()</code>调用时机时，发现设置了<code>android:configChanges=&quot;orientation&quot;</code>之后，Activity的任何周期回调均没有调用，但是屏幕中的画面却还是被旋转了，为什么？</li>
<li>在验证的时候发现，即使没有调用<code>onRestoreInstanceState()</code>也可以恢复view的信息，那为什么还会需要这个方法？为什么只在configChanges的时候才调用？</li>
</ul>
<h2 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h2><blockquote>
<p>以下勘误都仅限Android Programming这本书</p>
</blockquote>
<p>P80, 在<em>‘Saving Data Across Rotation’</em>这一节中，提到的onSaveInstanceState的默认实现有误，不是所有的views，而是有id的view。另外它还提到能放在SaveInstanceState里面的只能是基本类型和实现了Serializable接口的类，但明显实现Parcelable也是可以的，或者说更推荐后面这种方式。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://www.cnblogs.com/xiaoweiz/p/3813914.html" target="_blank" rel="external">同ID导致ScrollView位置信息被覆盖</a><br>《Android Programming: The Big Nerd Ranch Guide》 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前对这个函数功能不是太了解，在&lt;a href=&quot;https://brainku.github.io/2014/10/01/reading-android-develop-master/&quot;&gt;阅读《Android开发精要》&lt;/a&gt;这本书的过程中发现关于这个函数的描述存在矛盾。这个在Activity的生命周期中可能涉及到的函数做了什么，又是怎么做的，又有什么需要注意的，不弄懂的话说不过去~&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="https://brainku.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://brainku.github.io/tags/android/"/>
    
      <category term="源码" scheme="https://brainku.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="持久化" scheme="https://brainku.github.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="问题" scheme="https://brainku.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>小探Android应用层原理--《Android开发精要》</title>
    <link href="https://brainku.github.io/2014/10/01/reading-android-develop-master/"/>
    <id>https://brainku.github.io/2014/10/01/reading-android-develop-master/</id>
    <published>2014-10-01T02:03:34.000Z</published>
    <updated>2017-05-09T15:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前是翻过了一遍，只是没做总结的话似乎没什么印象。接下来就简要地总结一下书上提到的内容【估计也不简要-我做笔记总是会太注重细节】。内容会按照章节来做总结，不再细分小点。存在拓展性内容的话会重点描述，如果是官方的资料，那这里只会给出相应的链接。</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="第1章-Android的系统架构"><a href="#第1章-Android的系统架构" class="headerlink" title="第1章 Android的系统架构"></a>第1章 Android的系统架构</h3><h4 id="Android系统概况"><a href="#Android系统概况" class="headerlink" title="Android系统概况"></a>Android系统概况</h4><p>组成部分是<strong>应用层，框架层，运行时，核心类库，硬件抽象层（HAL）,Linux内核</strong>。<br>（在网上搜到的图基本上都忽略了硬件抽象层。这一层似乎是为了统一接口，向上屏蔽底层硬件的细节而存在。该层跟Linux间似乎也有一个bionic隔着。bionic是google实现的c系统库，为了防止GPL向上传染）<br><img src="http://www.anddev.org/images/android/system_architecture.png" alt="android"></p>
<ol>
<li><strong>应用层</strong><br>这一层基本用Java开发，也可以通过JNI调用C/C++的类库。在API9之后Android提供了<code>NativeActivity</code>来为用C/C++开发应用提供便利。但Google并未提供控件在核心类库的实现，所以如果使用C/C++开发，自己将无法使用控件，只能使用GL系列自己绘图。</li>
<li><strong>框架层</strong><br>最核心的部分，有多个系统服务组成。这些服务运行在系统核心进程，每个服务都是一个独立的线程。这些服务与外界通过binder进行IPC和RPC。<br>应用由多个组件组成，组件间的通讯是通过框架层的系统服务进行，集中的调度和传递信息，类似于外观模式(facade pattern)。</li>
<li><strong>运行时</strong><br>由Java的核心类库和Java虚拟机<a href="https://source.android.com/devices/tech/dalvik/index.html" target="_blank" rel="external">Dalvik</a>共同组成（曾经是，从5.0开始都是ART）<br>Dalvik使用采取了<strong>基于寄存器</strong>的虚拟机架构设计：基于寄存器的的虚拟机对硬件门槛更高，编译出的应用可能占用更多空间，但执行效率更高。<br>Dalvik没有采用字节码，而是在编译时将所有.class文件转换成.dex文件,使用的指令集为OpCodes。</li>
<li><strong>核心类库</strong><br>由一系列的二进制动态库共同组成，按需要而被加载到系统服务中。</li>
<li><strong>HAL和Linux Kernel</strong><br>HAL是Android为厂商提供的一套接口标准，为框架层提供接口。</li>
</ol>
<h4 id="架构特征和设计思想"><a href="#架构特征和设计思想" class="headerlink" title="架构特征和设计思想"></a>架构特征和设计思想</h4><p>Android的应用是高度组件化的，一个功能可能由多个组件共同完成，不会有明显的进程边界和应用边界。 </p>
<h3 id="第2章-源码获取与编译-略"><a href="#第2章-源码获取与编译-略" class="headerlink" title="第2章 源码获取与编译-略"></a>第2章 源码获取与编译-略</h3><h3 id="第3章-Android组件模型解析"><a href="#第3章-Android组件模型解析" class="headerlink" title="第3章 Android组件模型解析"></a>第3章 Android组件模型解析</h3><h4 id="基于Mashup的应用设计"><a href="#基于Mashup的应用设计" class="headerlink" title="基于Mashup的应用设计"></a>基于Mashup的应用设计</h4><p>基于组件的应用设计模式：每个应用由一系列的组件搭建而成，组件通过配置文件描述功能。<br>在Mashup的概念下描述应用，有三个基本元素：组件，连接和配置。</p>
<ol>
<li><strong>组件</strong>：有特定功能和接口规范的实现单元。</li>
<li><strong>连接</strong>：组件与组件间的通信信道。Android中提供的机制有Intent和Uri。</li>
<li><strong>配置</strong>：描述组件的功能和实现特征的信息。</li>
</ol>
<h4 id="Activity解析"><a href="#Activity解析" class="headerlink" title="Activity解析"></a>Activity解析</h4><ul>
<li>Android系统是个多任务的操作系统，对于每个任务都存在一个Activity栈与之对应。</li>
<li>Activity的实例则存在栈中，处在栈顶的组件即可见可交互的前台组件。</li>
<li>Activity继承自Context。ContextImpl和ContextWrapper各自实现了Context。但前者使用了ContextImpl的实例来完成功能，因而使得两者可以独立变化，彼此独立。<blockquote>
<p><strong>界面开发小tips</strong></p>
<ol>
<li>能用抽象控件尽量不要具体。在代码层使用View，而资源文件使用具体类型。【个人不赞同，如果需要频繁更改界面控件那反而应该反思，而不是写出这种代码</li>
<li>能用资源文件描述就不要用代码控制。【赞同，比如按下状态完全可以用xml中<code>selector</code>来实现。</li>
<li>降低界面复杂度，能用XML就用XML。【同上</li>
<li>不要在控件回调事件中放具体的代码。【提前告知了重构的规则，防止耦合。只是有时并没必要</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="Service解析"><a href="#Service解析" class="headerlink" title="Service解析"></a>Service解析</h4><ul>
<li>Service默认是不会运行在独立的进程或线程中，而是运行在应用进程的主线程中。</li>
<li>Service既可以像Activity一样作为调度者，也可以作为功能提供者。</li>
<li>Service提供两者使用方式，<code>startService</code>和<code>bindService</code>。这两者不同的地方在于，前者会导致<code>onStartCommand</code>被调用，但是后者是<code>onBind</code>被调用。通常前者还需要调用<code>stopSelf</code>来终止自己。<br>一般如果只是<code>startService</code>，建议使用IntentService重写<code>onHandleIntent</code>来代替。IntentService自动创建后台线程来提供服务。<br><del>书上在后面扯到了AIDL，这里不再对其进行说明</del><blockquote>
<p>小tips：<br>通过<code>getSystemService</code>拿到通常是该服务一个代理对象，这些对象与真正的服务线程建立连接，通过IPC调用来实现对应的方法。</p>
</blockquote>
</li>
</ul>
<h4 id="BroadCast-Receiver解析"><a href="#BroadCast-Receiver解析" class="headerlink" title="BroadCast Receiver解析"></a>BroadCast Receiver解析</h4><p>通常只会调用<code>onReceive</code>,生命周期也仅限于此。<br>Receiver接受两种注册方式，动态和静态两种方式【不想使用热插拔和冷插拔的说法】。</p>
<ol>
<li>静态方式。在配置文件中声明receiver，可以设置<code>Intent-filter</code>，也可以不设置。</li>
<li>动态方式。<code>registerReceiver()</code>和<code>unregisterReceiver()</code>。通常电量变化和时间改变的通知都是通过这种方式来注册的【因为这些事件通常是sticky（粘性）的，时常发生，使用静态方式需要频繁构造和销毁Receiver。】</li>
</ol>
<p>发送广播事件的方式也有两种。<code>sendBroadcast()</code>和<code>sendOrderedBroadcast()</code>，前者是普通广播事件，后者是有序广播。有序广播按照优先级次序依次发送，高优先级的Receiver可以调用<code>abortReceiver()</code>中止事件继续传播。另外，广播中也可以通过<code>setResult</code>和<code>getResultData</code>传递特定的数据。</p>
<blockquote>
<p>个人tips:<br>发送广播要特别注意安全的问题的。因为如果在配置文件设置了action，那么其他应用都可能调用到。为了保证广播只在本地进程被调用，可以使用<a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a></p>
</blockquote>
<h4 id="ContentProvider解析"><a href="#ContentProvider解析" class="headerlink" title="ContentProvider解析"></a>ContentProvider解析</h4><ul>
<li>负责为应用提供数据访问接口的组件，建议在应用共享数据时使用。它通过URI定位，使用SQL语句操作内容。  </li>
<li>在主线程构造和执行操作，如果需要异步，可以使用<code>AsyncQueryHandler</code>。  </li>
<li>操作数据时，通常使用ContentResolver。该类实例内缓存了ContentProvider的代理对象，从而可以通过“定位-执行”的这样的操作实现功能。所有的操作都是在消息队列中串行执行的，无法并发操作。   </li>
<li>ContentProvider在配置时可以设置<code>multprocess</code>,该项代表是否在另外一进程创建一实例。这样的好处在于减少IPC操作【不过数据的同步如何保证？复杂度会大大提高，所以不甚建议】</li>
</ul>
<h3 id="第4章-Android的Intent机制-略"><a href="#第4章-Android的Intent机制-略" class="headerlink" title="第4章 Android的Intent机制 略"></a>第4章 Android的Intent机制 略</h3><p>【个人觉得读过，了解一些常用的设置即可。也有可能是我现在没怎么接触到这样的需求，现在不做过多解读。经验多了，再来看这段话也许会觉得自己很无知？】<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">Intent.setType(<span class="string">"image/*"</span>);</div><div class="line">...</div><div class="line">IntentFilter.setPriority(<span class="number">1000</span>); <span class="comment">// -1000~+1000</span></div></pre></td></tr></table></figure></p>
<h3 id="第5章-组件生命周期解析"><a href="#第5章-组件生命周期解析" class="headerlink" title="第5章 组件生命周期解析"></a>第5章 组件生命周期解析</h3><h4 id="应用进程模型"><a href="#应用进程模型" class="headerlink" title="应用进程模型"></a>应用进程模型</h4><p><strong>定义：</strong>Android应用运行时，应用进程的分配和调度方式，以及应用组件和进程间的关系。</p>
<ul>
<li>默认情况下，应用进程名称与包名相同。</li>
<li>默认配置中，所以组件均在主线程。ApplicationContext在第一个组件加载前被初始化，在最后一个组件结束时被销毁。这个上下文对象为所有组件提供全局的功能和数据支持。</li>
<li>在manifest中通过<code>android:process</code>可以配置进程。如果名称前有冒号，说明是私有进程，仅有该应用的组件能够置入。如果是以小写字符开头则是共享进程，其他线程可访问。【可以参考这里<code>android:process</code>的<a href="http://stackoverflow.com/questions/7142921/usage-of-androidprocess" target="_blank" rel="external">用法</a><br><strong>实际开发中，通常需要将在逻辑上一起运行的组件配置到统一进程中。如一个共享进程中运行着Service，要调用Service的Receiver就必须跟它同一个进程。否则很有可能发生onReceiver时创建了进程，再去调用另外一个进程中Service，最后又结束了自己所处进程的情况。</strong>【这个场景真心没想过，不过在广播时确实有可能发生</li>
</ul>
<h4 id="应用进程托管"><a href="#应用进程托管" class="headerlink" title="应用进程托管"></a>应用进程托管</h4><p><strong>定义：</strong>Android的应用进程的构造和销毁均由系统统一调度。</p>
<ul>
<li>为何?    <ol>
<li>简化开发模型。组件间的跨进程通信的细节不对上层公布；</li>
<li>方便全局调度。优化进程对系统资源的使用。</li>
</ol>
</li>
<li>进程优先级：前台，可视，服务，后台，空进程<br> 如何区分？区分原则比较啰嗦，前台进程会涉及到很多组件的生命周期。<a href="http://developer.android.com/guide/components/processes-and-threads.html#Lifecycle" target="_blank" rel="external">具体的区分原则</a></li>
<li>进程回收。【跟Intent-Filter匹配类似的内容，不想赘述，记忆性的内容。<br>（小疑问，关于<code>onSaveInstanceState()</code>到底做了什么，仍然抱有疑问。真的是作者说的存到磁盘？）</li>
<li>终止进程。如果进程发生了意外，无法继续执行而成为异常进程。此时Android会终止这个进程，但是会先保留它的task，并重新创建进程和恢复它的task，除了最顶层的Activity。</li>
<li>ANR：此时的终止是不会给你复活的← ←<ol>
<li>对用户的操作（键盘或触屏事件）超过5秒未响应。</li>
<li>广播接收器的onReceiver执行超过10秒。</li>
</ol>
</li>
</ul>
<h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><ul>
<li>从构造运行开始到被销毁的时段内，组件的状态变化。（可以思考一下为什么Android要提供这种状态变化）</li>
<li>各种组件的具体生命周期。【Activity除了状态缓存，基本没有什么，接下来是一些补充。</li>
<li>关于Service的<code>onStartCommand</code>的返回值：<ul>
<li><code>START_STICKY</code>，即使被强行回收了，有空闲内存时仍会再调用它，除非服务自己调用<code>stopSelf()</code>；</li>
<li><code>START_NOT_STICKY</code>，系统不管服务是否完成，无条件终结后不再负责复活。</li>
<li><code>START_REDELIVER_INTENT</code>，保证Service能够完整地处理每个Intent对象。如果处理到一半被终结，则再调用，再投递同一个Intent。</li>
</ul>
</li>
</ul>
<h4 id="Task和Activity-Stack"><a href="#Task和Activity-Stack" class="headerlink" title="Task和Activity Stack"></a>Task和Activity Stack</h4><ul>
<li>在Stack中，不处在相邻位置的Activity无法相互调用。</li>
<li>启动模式有4种。划分规则是1.是否复用对象；2.是否只作为栈的根组件而存在。singleTask和singleInstance适用于消耗内存较多的单实例Activity，如浏览器和音乐播放器。</li>
<li>Task Affinity（Task亲和度）：组件期望和哪些组件分配到同一个Task中。常在<code>android:taskAffinity</code>配置同一名称的Task。另外还需要另外配置<code>android:allowTaskReparenting</code>或者设置Intent的Flags为<code>FLAG_ACTIVITY_NEW_TASK</code>。关于后面那种设置，一般是要将组件作为Root Activity，但如果设置了亲和度，则会先去寻找具有同名的Task。</li>
</ul>
<h3 id="第6章-组件间的数据传输"><a href="#第6章-组件间的数据传输" class="headerlink" title="第6章 组件间的数据传输"></a>第6章 组件间的数据传输</h3><h4 id="使用Intent对象传输数据"><a href="#使用Intent对象传输数据" class="headerlink" title="使用Intent对象传输数据"></a>使用Intent对象传输数据</h4><ul>
<li>在<code>startActivity</code>和<code>startActivityForResult</code>等启动组件的时候使用。【知道使用方式即可。result中有两个默认选项<code>RESULT_OK</code>,<code>RESULT_CANCEL</code>。<code>RESULT_CANCEL</code>的情况比较少见，但也可能会遇到，此时的<code>startActivityForResult</code>是调用后马上返回的，所以比较好判断。】</li>
<li><strong>优点：</strong>开发便捷，跨进程和跨应用。</li>
<li><strong>缺点：</strong>传输开销大（至少两次序列化和反序列化）,不适合在多个组件间共享数据（代码耦合和实现成本高）</li>
<li>Intent适合于两个组件间点对点传输。如果传输的数据较大，建议存在磁盘，再通过uri传输【小米的Intent中不能放较大bitmap，不然就会跪= =】</li>
</ul>
<h4 id="使用文件进行数据共享"><a href="#使用文件进行数据共享" class="headerlink" title="使用文件进行数据共享"></a>使用文件进行数据共享</h4><ul>
<li><code>Context.openFileOutput()</code>可以创建或打开私有的文件。</li>
<li><strong>优点：</strong>方便多个组件对象间的数据共享和传输</li>
<li><strong>缺点：</strong>读写开销大，开发成本较高，若在SD卡上安全问题严重</li>
<li>有持久化需求的小数据共享【我更加建议用Preference</li>
</ul>
<h4 id="使用Application全局共享"><a href="#使用Application全局共享" class="headerlink" title="使用Application全局共享"></a>使用Application全局共享</h4><ul>
<li>继承Application并在manifest中配置</li>
<li><strong>优点：</strong>效率高，可实现不需要持久化的数据共享</li>
<li><strong>缺点：</strong>不支持跨进程和线程，可能占用更多的空间</li>
</ul>
<h4 id="利用组件共享数据"><a href="#利用组件共享数据" class="headerlink" title="利用组件共享数据"></a>利用组件共享数据</h4><ul>
<li>使用ContentProvider.<strong>优点：</strong>更安全，快捷，适用于关系型数据</li>
<li>使用Bound Service简单共享数据</li>
</ul>
<h3 id="第7章-Android控件解析"><a href="#第7章-Android控件解析" class="headerlink" title="第7章 Android控件解析"></a>第7章 Android控件解析</h3><h4 id="Android的控件框架"><a href="#Android的控件框架" class="headerlink" title="Android的控件框架"></a>Android的控件框架</h4><ul>
<li>控件均继承自View，包括ViewGroup。</li>
<li>控件最终形成一棵控件树。上层父控件负责下层子控件的排列和绘制，并将交互事件自上而上传递到子控件。每棵控件树都有一个ViewParent对象与其根控件绑定，这个对象是整个树交互事件的控制枢纽。控件树中每个控件都包含一个指向ViewParent的引用，当子控件的焦点尺寸改变时会通知该ViewParent对象由该对象统一向下分发。</li>
<li>交互事件传递。当父控件收到交互事件后，会先判定事件的目标控件对象，如果自己需要则处理（可能拦截），否则向下分发，直到事件被处理或被忽略。        </li>
<li>控件的测量和绘制。从上到下一次调用<code>measure()</code>测量和<code>layout()</code>定位，最后调用<code>onDraw()</code>绘图。【<code>onMeasure()</code>和<code>onLayout()</code>可被重写，但上面两个方法是final的】</li>
</ul>
<h4 id="Android的窗口机制"><a href="#Android的窗口机制" class="headerlink" title="Android的窗口机制"></a>Android的窗口机制</h4><ul>
<li>Android将用户的操作转变成事件传递到交互界面上是通过窗口机制来实现的，即基于窗口注册的实现模式。</li>
<li>WindowManger统一管理所有的ViewParent（实现类是ViewRoot）。在创建完界面后，ViewRoot会向WindowManger注册，并建立双向通信的连接。当产生事件时，系统底层框架将事件转换并传递到窗口管理服务中，窗口管理服务解析操作并转换为交互事件。接着再定位当前与用户交互的窗口，将交互事件转发给对应的ViewRoot。</li>
<li>WindowManger会为每个窗口分配一个窗口层次z-order。越晚添加的窗口，窗口层次越高。另外，系统的交互模块会具有更高的基础窗口层次。</li>
<li>每个Activity都会有一个Window对象，每个对象都会负责构造和管理一棵控件树，并为该控件树构造对应的ViewRoot对象与窗口管理服务的双向通信。</li>
<li>可以通过<code>requestWindowFeature()</code>设置窗口的样式。注意这个方法需要在<code>setContentView</code>前调用。如果是<code>setFeatureInts</code>则需要在之后调用。</li>
<li>每个Dialog也包含一个窗口对象【<strong>在使用Builder时传入的context不能为Application，因为Application不能调用窗口服务，谨记。</strong></li>
<li>PopupWindow，弹出窗口，该控件不包含Window对象，它自身自行管理控件树与窗口服务通信。PopupWindow依赖于AnchorView(锚点控件）的窗口服务。而AnchorView的窗口服务通常是异步建立的【在setContentView时不一定完成】，所以需要将PopupWindow的初始化操作post进AnchorView的消息队列中，等待其连接建立后再初始化。</li>
</ul>
<h4 id="Android基本控件-【简略"><a href="#Android基本控件-【简略" class="headerlink" title="Android基本控件 【简略"></a>Android基本控件 【简略</h4><ul>
<li>TextView有一个很重要的辅助类来实现富文本：SpannableString【图文混排怎么做？</li>
<li>SurfaceView具有独立的窗口，而不需要受父控件控制。但同时它也需要处理自己的布局及大小测量。</li>
</ul>
<h4 id="自定义控件和自绘控件-【略"><a href="#自定义控件和自绘控件-【略" class="headerlink" title="自定义控件和自绘控件 【略"></a>自定义控件和自绘控件 【略</h4><p>【简单介绍了一下自定义控件的类型还有SurfaceView系列，其他没什么了</p>
<h3 id="第8章-Android应用资源"><a href="#第8章-Android应用资源" class="headerlink" title="第8章 Android应用资源"></a>第8章 Android应用资源</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul>
<li>在raw文件夹中的文件需要通过<code>Resource.openRawresource()</code>打开。而在assert目录的文件需要使用AssertManager来读取。</li>
<li>可以在<code>android:configChanges</code>中声明不关注的设备配置项，当这些配置项目改变时不需要销毁和重新构造组件，而直接调用<code>Activity.onConfigurationChanged()</code>来通知配置更改事件。常用的配置的有<code>orientation</code>和<code>keyboardHidden</code>。</li>
</ul>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul>
<li>Android的资源文件的处理：预编译，编译及打包。【注意这个过程在4.0后已经改变<ul>
<li>预编译：使用aapt对资源文件进行解析，生成R和App._ap文件</li>
<li>编译：将R文件与其他文件一起编译成.class，再用dx打包成.dex</li>
<li>打包：使用apkbuilder将dex，资源文件等打包成apk</li>
</ul>
</li>
</ul>
<h3 id="第9章-数据存储"><a href="#第9章-数据存储" class="headerlink" title="第9章 数据存储"></a>第9章 数据存储</h3><ul>
<li>结构目录。应用的安装包会被放在/data/app目录下；在安装时会将dex文件解析成odex文件后存储在dalvik-cache目录下；应用产生的数据会被放在/data/data/目录下；</li>
</ul>
<blockquote>
<p>小tips：<br>在2.2后，可以通过在manifest中配置<code>android:installLocation=&quot;preferExternal&quot;</code>将应用安装到外部存储中，但/data/data文件仍然是在内部存储中【安全问题</p>
</blockquote>
<h4 id="使用数据库。"><a href="#使用数据库。" class="headerlink" title="使用数据库。"></a>使用数据库。</h4><ul>
<li>Android在Java层使用CursorWindow机制来控制对数据库的读取。并非一次性地取出所有资料，而是构造一个数据窗口来动态映射部分数据行，将这些数据行从数据库中读取出来并缓存在上层对象中。访问时如果命中，则直接返回，否则通过JNI再去调取数据。</li>
<li>为了提高性能，可以通过SQLiteStatement预编译SQL语句。</li>
<li>通过同一个SqliteDatabase对象访问数据库时线程安全的，因为Android会对数据库进行加锁保护。如果在使用时，出现了指向同一个数据库的多个对象同时在多个线程中被使用，就会抛出<code>database is locked</code>的异常。</li>
<li>在实践中，需要保证同时访问数据库的SqliteDatabase对象仅有一个。</li>
<li>【关于SQLite的使用待做文章细说。</li>
</ul>
<h3 id="第10章-网络通信"><a href="#第10章-网络通信" class="headerlink" title="第10章 网络通信"></a>第10章 网络通信</h3><h4 id="Web通信"><a href="#Web通信" class="headerlink" title="Web通信"></a>Web通信</h4><ul>
<li>使用HTTPClient。步骤:1 实例化HttpClient；2 实例化 HttpUriRequest；3 接收处理HttpResponse</li>
<li>默认情况下DefaultHttpClient（HttpClient的一个默认实现）是线程非安全的，不能同时在多个线程中同时调用DefaultHttpClient对象的方法。如果有线程安全和超时控制的要求，可以使用AndroidHttpClient。</li>
<li>P2P，NFC及WIFI等略【只是简单介绍，真需要使用的时候也可以很快理解</li>
</ul>
<h3 id="第11章-地理信息服务-略"><a href="#第11章-地理信息服务-略" class="headerlink" title="第11章 地理信息服务 略"></a>第11章 地理信息服务 略</h3><p>【如果有需要的话，自己查去</p>
<h3 id="第12章-多媒体处理"><a href="#第12章-多媒体处理" class="headerlink" title="第12章 多媒体处理"></a>第12章 多媒体处理</h3><h4 id="图像的处理"><a href="#图像的处理" class="headerlink" title="图像的处理"></a>图像的处理</h4><ul>
<li>永远记得调用<code>Bitmap.recycle()</code>。【为了3.0之前的手机能够哦正常释放Bitmap的Native peer</li>
<li>Nine-Patch：图像左，上的区域控制图像区域拉伸，右，下的区域控制文字出现的范围。</li>
<li>Bitmap.Options这个类中，in*系列代表图像读取的输入参数，out*系列代表图片的基本信息，如果长宽，类型等。</li>
</ul>
<h4 id="音频-略"><a href="#音频-略" class="headerlink" title="音频 略"></a>音频 略</h4><h4 id="相机的使用"><a href="#相机的使用" class="headerlink" title="相机的使用"></a>相机的使用</h4><ul>
<li>可以通过<code>Camera.getCameraInfo()</code>来获取相机的基本信息。</li>
<li>在Android中，任何一个相机的资源都是独占的，永远只有一个程序能够控制相机。所以通常会在onResume时获取，onPause时释放。</li>
<li>相机的预览通常使用SurfaceView。为了使预览过程足够清晰，Android使用YCrCb格式存储预览数据。如需转码，还请自己来。</li>
</ul>
<h3 id="第13章-其他模块"><a href="#第13章-其他模块" class="headerlink" title="第13章 其他模块"></a>第13章 其他模块</h3><h4 id="AppWidget【有需要再复习"><a href="#AppWidget【有需要再复习" class="headerlink" title="AppWidget【有需要再复习"></a>AppWidget【有需要再复习</h4><h2 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h2><ul>
<li>P151，事件是在控件树从上往下，而非相反</li>
<li>P241，通过<code>getWriteableDatabase()</code>和<code>getReadableDatabase()</code>获取的数据库均可以读写，而不是后者仅限于读。作者理解有误</li>
<li>P285，调用<code>Bitmap.recycle()</code>之后并不是马上释放了内存。只是告知这个Bitmap可以回收而已。在3.0之前这个操作的意义还在于释放native peer（这也可能是作者说马上释放了内存的原因）。而在3.0之后，Bitmap是在VM的堆中分配的，可以不调用<code>recycle()</code>，而只要将Bitmap的引用置为NULL即可。吗</li>
<li>出现多次的错误：Application的<code>onTerminal()</code>事件只会在AVD中触发，真实设备是不会发生该事件的。作者把这个事件理解成跟<code>finalize()</code>类似的概念了。</li>
<li>10.22 update: P110，作者关于onSaveInstanceState调用时机的图是有错的，作者给出的图只适合Honeycomb之前的android。具体参考<a href="https://brainku.github.io/2014/10/07/something-about-onsaveinstancestate/">这里</a></li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>写完这篇博客之后尚未解决的疑问，估计要研究一下</p>
<ol>
<li><code>onSaveInstanceState()</code>到底会做什么？作者一开始说存到磁盘，后又说是使用bundle形式保存，明显存在矛盾。另外，关于<code>onSaveInstance()</code>与<code>onRestoreInstanceState()</code>的调用时机也不明确。作者说如果是用户按下HOME键主动退出是不会调用的，果真如此吗？<br><a href="https://brainku.github.io/2014/10/07/something-about-onsaveinstancestate/">关于onSaveInstanceState的那点事</a></li>
<li>SQlite是表级别的锁，那么支持并发吗?Locked状态是怎么回事？</li>
<li>图文混排如何实现？</li>
</ol>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><ul>
<li>再次翻完了并做了笔记，比预料的多花了不少时间。如果只是记录一些自己不是太了解的内容，这本书上能写的应该不多吧。笔记应该是自己所不熟悉的，还有就是一些简洁的总结性内容。下次是不是可以只是选择性地只记录一些概要性的内容,对于已知的不做过度描述。  10.4 21:56</li>
<li>国庆的第一天，中午饭就不想吃了。睡了一个中午，也不饿。我对假期总有这样的感觉吗 10.1 15:15</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前是翻过了一遍，只是没做总结的话似乎没什么印象。接下来就简要地总结一下书上提到的内容【估计也不简要-我做笔记总是会太注重细节】。内容会按照章节来做总结，不再细分小点。存在拓展性内容的话会重点描述，如果是官方的资料，那这里只会给出相应的链接。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="https://brainku.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="笔记" scheme="https://brainku.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="https://brainku.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="android" scheme="https://brainku.github.io/tags/android/"/>
    
      <category term="疑问" scheme="https://brainku.github.io/tags/%E7%96%91%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解C指针》 &gt;= Ch6</title>
    <link href="https://brainku.github.io/2014/09/17/deep-in-c-pointer-ch-after-5/"/>
    <id>https://brainku.github.io/2014/09/17/deep-in-c-pointer-ch-after-5/</id>
    <published>2014-09-17T15:34:46.000Z</published>
    <updated>2016-08-20T12:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-6-指针和结构体"><a href="#Chap-6-指针和结构体" class="headerlink" title="Chap 6 指针和结构体"></a>Chap 6 指针和结构体</h1><h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a><strong>字节对齐</strong></h2><p>结构体尤其要注意的问题是：<strong>字节对齐</strong></p>
<blockquote>
<p>Data alignment means putting the data at a memory offset equal to some multiple of the word size, which increases the system’s performance due to the way the CPU handles memory –来自WIKI</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一定使用typedef才可以在后面sizeof中直接使用Node</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></div><div class="line">	<span class="keyword">char</span>* content;</div><div class="line">	<span class="keyword">char</span>* test;</div><div class="line">	<span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">short</span> s1;</div><div class="line">	<span class="keyword">short</span> s2;</div><div class="line">&#125; Node;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(Node)); <span class="comment">// 24</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我64位的机器上输出是24。<del>我老是忘记只有指针的大小跟机器的位数有关- -。</del><br>两个 <code>char*</code> 16字节，<code>int</code> 4字节， 两个 <code>short</code> 4字节。去掉所有的short，也还是24字节。<br>实际上是按照结构体中最大的单元的n倍来分配空间的。<br>上面最大的<strong>结构单元</strong>是8字节的指针，那么结构体占有的空间只能是8的倍数。<br>如果一个结构体中包含另外一个结构体，那么最小的 <strong>结构单元</strong> 是另外一个结构体与当前结构体中合起来的所有成员中最占内存的单位（而不是把被包含的结构体作为一个单位）<br>再看一个对齐的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></div><div class="line">	<span class="keyword">char</span> a[<span class="number">10</span>]; </div><div class="line">	<span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">char</span> gender;</div><div class="line">&#125; Node; <span class="comment">//20</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </div><div class="line">	<span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">char</span> gender;</div><div class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];</div><div class="line">&#125; Node; <span class="comment">//16</span></div></pre></td></tr></table></figure></p>
<p>输出都写在上面了。当把小单位的单元放在一起时不先考虑packed的问题，小的东西先挤挤看~后面那种情况可以挤一下，于是变成 <code>char[11]</code> 不到12字节，就填成12字节，最后也就形成了16字节的空间。<br>而上面那种情况，是由于int在中间隔断了两个char,导致虽然两个char相邻，但也只能被分别packed~最后就是20字节啦。</p>
<h2 id="创建与释放"><a href="#创建与释放" class="headerlink" title="创建与释放"></a><strong>创建与释放</strong></h2><p>创建不提，结构体比较容易出现的问题是在释放的时候。经常会出现忘记释放分配的内存的情况，小心谨慎即可。</p>
<p>关于结构体成员变量的访问，如果是结构体指针直接用 <code>-&gt;</code> 即可，如果是结构体的一个变量，就用点操作符。<br>为减少 <code>malloc</code> 和 <code>free</code> 的开销，可以适当地使用缓存池~<br>简单的思路就是：</p>
<ol>
<li>在 <code>get</code> 时查看表中是否存在对象，有则返回，并将该位置置为NULL, 否则创建新对象再返回。 </li>
<li>用完对象之后，调用类似于 <code>release</code> 的方法。 此时看缓存池里面有没有空位，有空位就塞进去，没有就直接释放。</li>
</ol>
<h1 id="Chap-7-安全问题和指针误用"><a href="#Chap-7-安全问题和指针误用" class="headerlink" title="Chap 7 安全问题和指针误用"></a>Chap 7 安全问题和指针误用</h1><h2 id="7-1-指针的声明和初始化"><a href="#7-1-指针的声明和初始化" class="headerlink" title="7.1 指针的声明和初始化"></a>7.1 指针的声明和初始化</h2><h4 id="不恰当的指针声明"><a href="#不恰当的指针声明" class="headerlink" title="不恰当的指针声明"></a><strong>不恰当的指针声明</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* ptr1, ptr2; <span class="comment">// 声明了两个变量，前面一个整型指针，后面一个为整型</span></div><div class="line"><span class="keyword">int</span> *ptr1, *ptr2; <span class="comment">// 正确的写法~或者下面这种</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* PINT</div><div class="line">PINT ptr1, ptr2;</div></pre></td></tr></table></figure>
<h4 id="使用指针前未初始化"><a href="#使用指针前未初始化" class="headerlink" title="使用指针前未初始化"></a><strong>使用指针前未初始化</strong></h4><p>初始化之前就使用指针会导致运行时错误，这种指针也被称为 <strong>野指针</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi; </div><div class="line"><span class="comment">// 这里可能可以打印出什么脏数据</span></div><div class="line"><span class="comment">// 但也可能因为能够表示的地址不合法而让程序直接崩掉</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *pi);</div></pre></td></tr></table></figure></p>
<h2 id="7-2-指针的使用问题"><a href="#7-2-指针的使用问题" class="headerlink" title="7.2 指针的使用问题"></a>7.2 指针的使用问题</h2><p>可能导致缓冲区溢出的情况：</p>
<ol>
<li>访问数据时不考虑边界</li>
<li>对数组指针进行算数运算导致越界</li>
<li>使用gets之类的函数从输入中读取字符串<br>4.<strong>误用strcpy和strcat这样的函数</strong></li>
</ol>
<h4 id="错误的解引用"><a href="#错误的解引用" class="headerlink" title="错误的解引用"></a><strong>错误的解引用</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="keyword">int</span> *pi;</div><div class="line">*pi = &amp;num; <span class="comment">//这里是将num的地址赋给了pi所对应的内存（的值），但是pi还未初始化- -</span></div><div class="line"><span class="keyword">int</span>* pi = &amp;num; <span class="comment">//正确。*代表的时候指针，不要跟解引用搞混</span></div></pre></td></tr></table></figure>
<h4 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a><strong>越界访问</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> firstname[] = <span class="string">"1234567"</span>;</div><div class="line"><span class="keyword">char</span> middlename[] = <span class="string">"1234567"</span>;</div><div class="line"><span class="keyword">char</span> lastname[] = <span class="string">"1234567"</span>;</div><div class="line"></div><div class="line">middlename[<span class="number">-2</span>] = <span class="string">'X'</span>;</div><div class="line">middlename[<span class="number">0</span>] = <span class="string">'X'</span>;</div><div class="line">middlename[<span class="number">10</span>] = <span class="string">'X'</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%p %s\n"</span>, firstname, firstname);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%p %s\n"</span>, middlename, middlename);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%p %s\n"</span>, lastname, lastname);</div></pre></td></tr></table></figure>
<p>预计的输出应该是，lastname的地址最大，firstname的地址最小，且firstname跟lastname都有一个数被修改。<br>但实际上devC++输出是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">000000000023F</span>E40 <span class="number">1234567</span></div><div class="line"><span class="number">000000000023F</span>E30 X234567</div><div class="line"><span class="number">000000000023F</span>E20 <span class="number">1234567</span></div></pre></td></tr></table></figure></p>
<p>应该是有做防缓冲区溢出的检测吧。</p>
<h4 id="错误计算数组长度"><a href="#错误计算数组长度" class="headerlink" title="错误计算数组长度"></a><strong>错误计算数组长度</strong></h4><p>尽量地少用 <code>strcpy</code> 这样不需要长度信息的函数。</p>
<h4 id="错误使用sizeof"><a href="#错误使用sizeof" class="headerlink" title="错误使用sizeof"></a><strong>错误使用sizeof</strong></h4><p><em>对于数组指针而言，sizeof返回的是字节数，而非数组元素的个数</em><br>另外在作为函数传递的时候，数组指针可能会退化为字符串指针，这个时候的sizeof就只是指针所占的空间而已了。无论参数呈现什么形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> test[])</span> </span>&#123; <span class="comment">// 我的机器这里是8字节</span></div><div class="line"><span class="comment">// void test(char* test) &#123; // 同上 </span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(test));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="不匹配的指针类型"><a href="#不匹配的指针类型" class="headerlink" title="不匹配的指针类型"></a><strong>不匹配的指针类型</strong></h4><p>是什么指针，就用对应的内存。比如short类型的指针，如果把int类型的指针赋给它，它也只能用2字节。</p>
<h4 id="有界指针"><a href="#有界指针" class="headerlink" title="有界指针"></a><strong>有界指针</strong></h4><p><del>C中没有智能指针，所以基本没法控制</del></p>
<h4 id="字符串的安全"><a href="#字符串的安全" class="headerlink" title="字符串的安全"></a><strong>字符串的安全</strong></h4><p>慎用单纯的<code>strcpy</code>。最好用<code>scan_s</code>来防止缓冲区溢出。</p>
<h4 id="指针算数运算和结构体"><a href="#指针算数运算和结构体" class="headerlink" title="指针算数运算和结构体"></a><strong>指针算数运算和结构体</strong></h4><p>由于<code>data structure padding</code> 的存在，对指针的算数运算可能会错误地访问到这些内容。</p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><strong>函数指针</strong></h4><p>在c中，以下几种使用函数的方式都不会发出警告<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="number">0</span>;  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; getNumber &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; (getNumber == <span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; (getNumber() == <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//1 0 1</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>另外关于书中提到的函数指针类型参数不匹配但是仍然能够通过编译的现象在我的编译环境上并不存在。在GCC上并不能编译通过，会提示参数类型不匹配。</p>
</blockquote>
<h2 id="7-3-内存释放问题"><a href="#7-3-内存释放问题" class="headerlink" title="7.3 内存释放问题"></a>7.3 内存释放问题</h2><h4 id="避免重复释放"><a href="#避免重复释放" class="headerlink" title="避免重复释放"></a><strong>避免重复释放</strong></h4><p>在使用完指针之后将其置为<code>NULL</code></p>
<h4 id="清除敏感数据"><a href="#清除敏感数据" class="headerlink" title="清除敏感数据"></a><strong>清除敏感数据</strong></h4><p>敏感数据，用完马上复写。<code>memset(ptr, 0, size)</code>是个不错的选择。</p>
<h2 id="关于第八章"><a href="#关于第八章" class="headerlink" title="关于第八章"></a>关于第八章</h2><p>讲到了关于<strong>转换指针（将数值强转为地址）</strong>以及<strong>别名</strong>，和<strong>如何用函数指针实现回调</strong>和<strong>如何用结构体，函数指针设计简单的面向对象</strong>。这块内容不做过多讨论~</p>
<h3 id="一点小补充"><a href="#一点小补充" class="headerlink" title="一点小补充"></a>一点小补充</h3><p>突然间发现，原来C是没有bool类型的啊orz<br>也不支持重载。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chap-6-指针和结构体&quot;&gt;&lt;a href=&quot;#Chap-6-指针和结构体&quot; class=&quot;headerlink&quot; title=&quot;Chap 6 指针和结构体&quot;&gt;&lt;/a&gt;Chap 6 指针和结构体&lt;/h1&gt;&lt;h2 id=&quot;字节对齐&quot;&gt;&lt;a href=&quot;#字节对齐&quot; class=&quot;headerlink&quot; title=&quot;字节对齐&quot;&gt;&lt;/a&gt;&lt;strong&gt;字节对齐&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;结构体尤其要注意的问题是：&lt;strong&gt;字节对齐&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Data alignment means putting the data at a memory offset equal to some multiple of the word size, which increases the system’s performance due to the way the CPU handles memory –来自WIKI&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://brainku.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="https://brainku.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解C指针》 Ch5</title>
    <link href="https://brainku.github.io/2014/09/17/deep-in-c-pointer-ch-5/"/>
    <id>https://brainku.github.io/2014/09/17/deep-in-c-pointer-ch-5/</id>
    <published>2014-09-17T12:34:31.000Z</published>
    <updated>2016-08-20T13:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap5-指针和字符串"><a href="#Chap5-指针和字符串" class="headerlink" title="Chap5 指针和字符串"></a>Chap5 指针和字符串</h1><h2 id="5-1-基础"><a href="#5-1-基础" class="headerlink" title="5.1 基础"></a><strong>5.1 基础</strong></h2><blockquote>
<p>字符常量时单引号引起来的字符序列。字符常量通常由一个字符组成，也可包含多个字符（如转义）。在C中，字符常量是<strong>int类型</strong>。</p>
</blockquote>
<p>声明字符串的方式有三种: 字面量，字符数组，字符指针。<br>字符串字面量是用双引号包裹的字符序列，它位于字符串字面量池中。<br><strong>！</strong>跟单引号的字符字面量不同<br><a id="more"></a></p>
<h3 id="字符串字面量池"><a href="#字符串字面量池" class="headerlink" title="字符串字面量池"></a><strong>字符串字面量池</strong></h3><p>定义字面量时通常会将其分配在字面量池中，这个区域保存了组成字符串的字符序列。多次用到同一个字面量时，字面量池通常也只有一份副本。</p>
<blockquote>
<p><strong>通常</strong>情况下，字符串字面量是不可修改的（不然会导致指向这个字符串字面常量的所有引用数值都改变）。但你不能保证编译器会告诉你。<br>下面这段代码，在DevC++，使用GCC可以编译通过，但是在实际执行时会报段错误。<br><strong>建议将这种指向字符串字面量的指针设置为const，如此就算一不小心修改了，也能够在编译时得到错误。将失败提前是一种有效避免bug的方式</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *a = <span class="string">"hello world"</span>;</div><div class="line"><span class="comment">// const char *a = "hello world"; 建议</span></div><div class="line">*a = <span class="string">'L'</span>; </div><div class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, a);</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a><strong>字符串初始化</strong></h3><p>字符串所对应的内存要么是一块内存，要么是数组。<br>几种初始化方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> header[] = <span class="string">"hello world"</span>; <span class="comment">//将常量池中的内容复制到数组中（注意长度总是要比strlen + 1('/0')</span></div><div class="line"><span class="keyword">char</span> header1[<span class="number">12</span>];<span class="built_in">strcpy</span>(header1,<span class="string">"hello world"</span>);</div><div class="line"><span class="keyword">char</span> *header2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">12</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="built_in">strcpy</span>(header2,<span class="string">"hello world"</span>);</div><div class="line"><span class="keyword">char</span> *header3 = <span class="string">"hello world"</span>; <span class="comment">//直接将字符串字面量的地址赋给header3--也就是指向唯一一个常量。</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面有种初始化方式是将字符串字面量直接赋给字符串指针。那么如果字符字面量又如何？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// char *c = 'a'; 直接报错。上面提到过，字符字面量是int类型，上述行为就相当于将整数赋给字符指针。</span></div><div class="line"><span class="comment">// 在解引用的时候就会报错了。这里的错误就是相当于，未初始化变量导致的错误= =</span></div><div class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1</span>); *c = <span class="string">'+'</span>;</div><div class="line"><span class="comment">// 这样子是合法的，因为'+'并不会超过128，也就不会溢出。两者都分配了空间，也就能够正常调用了。</span></div><div class="line"><span class="keyword">char</span> c[<span class="number">1</span>]; c[<span class="number">0</span>] = <span class="string">'a'</span>;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a><strong>位置</strong></h3><p>全局指针，静态变量指针的字符串变量均指向字符串字面量。<br>数组则是对应的空间-比如全局和静态都在全局内存，其他在栈中，或者堆中。</p>
<h2 id="5-2-字符操作"><a href="#5-2-字符操作" class="headerlink" title="5.2 字符操作"></a><strong>5.2 字符操作</strong></h2><p><code>int strcmp(const char* s1, const char* s2)</code><br>如果小于0，则代表s1&lt;s2,其他类推（这么想就好了s1-s2&lt;0)<br><code>char* strcpy(char* dst, const char* from)</code><br>复制指定字符串到特定的地址。返回的是指向’\0’前一个位置的地址（最好不要用返回值） </p>
<blockquote>
<p>默认的实现是需要先为dst分配空间再传入的。稍微实现一个传入未分配空间的字符串指针的拷贝函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">char</span>* src)</span> </span>&#123;</div><div class="line">	dst = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src) + <span class="number">1</span>);</div><div class="line">	<span class="keyword">char</span>* tmp = dst;</div><div class="line">	<span class="keyword">while</span> (*dst++ = *src++);</div><div class="line">	<span class="keyword">return</span> tmp; <span class="comment">//如果返回了指针，记得在使用完后释放内存free~</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>char* strcat(char* dst, const char* from)</code><br>dst必须有足够的内存，否则会覆盖。函数返回拼接后字符串的首地址,也就是dst。注意前面的’\0’会被清除。</p>
<h2 id="5-5-函数指针和字符串"><a href="#5-5-函数指针和字符串" class="headerlink" title="5.5 函数指针和字符串"></a><strong>5.5 函数指针和字符串</strong></h2><p>将字符转为小写的函数：<br>【感觉我有严重的误解= =const char*代表不可以通过指针修改值，但是指针可以指向其他值。<strong>它认为它自己指向的是常量</strong> 】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">stringToLower</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span>* tmp = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="built_in">string</span>)+<span class="number">1</span>);</div><div class="line">	<span class="keyword">char</span>* start = tmp;</div><div class="line">	<span class="keyword">while</span> (*<span class="built_in">string</span> != <span class="number">0</span>) &#123;</div><div class="line">		*tmp++ = <span class="built_in">tolower</span>(*<span class="built_in">string</span>++);</div><div class="line">	&#125;</div><div class="line">	*tmp = <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> start;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来这样子可以创建函数指针类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(name*)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;<span class="comment">// return type, function name, params</span></div></pre></td></tr></table></figure></p>
<h2 id="测试小题目"><a href="#测试小题目" class="headerlink" title="测试小题目"></a>测试小题目</h2><blockquote>
<p>9-18：突然间有个疑问，觉得可以作为一个问题来问下~刚好跟这章内容有关~</p>
</blockquote>
<p>考虑以下代码的输出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span>* a = <span class="string">"arr"</span>;</div><div class="line">	<span class="keyword">char</span>  b[] = <span class="string">"arr"</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a == <span class="string">"arr"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b == <span class="string">"arr"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解答：==在c里面的含义还是一般意义上相等，也就是比较数值。这里比较的都是指针的地址，<code>&quot;arr&quot;</code> 是一串分配在字面量常量池中的字面量，这里将它理解成一个指向这个字面量的常量指针。那么很明显地可以得出答案了吧~数组b是分配在栈上的，地址明显跟常量池的 <code>&quot;arr&quot;</code> 不同。而关于 a 常量池中同一字符串通常只有一份副本。所以最后的输出是；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chap5-指针和字符串&quot;&gt;&lt;a href=&quot;#Chap5-指针和字符串&quot; class=&quot;headerlink&quot; title=&quot;Chap5 指针和字符串&quot;&gt;&lt;/a&gt;Chap5 指针和字符串&lt;/h1&gt;&lt;h2 id=&quot;5-1-基础&quot;&gt;&lt;a href=&quot;#5-1-基础&quot; class=&quot;headerlink&quot; title=&quot;5.1 基础&quot;&gt;&lt;/a&gt;&lt;strong&gt;5.1 基础&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;字符常量时单引号引起来的字符序列。字符常量通常由一个字符组成，也可包含多个字符（如转义）。在C中，字符常量是&lt;strong&gt;int类型&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;声明字符串的方式有三种: 字面量，字符数组，字符指针。&lt;br&gt;字符串字面量是用双引号包裹的字符序列，它位于字符串字面量池中。&lt;br&gt;&lt;strong&gt;！&lt;/strong&gt;跟单引号的字符字面量不同&lt;br&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://brainku.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="https://brainku.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解C指针》 Chap1&amp;2</title>
    <link href="https://brainku.github.io/2014/09/15/deep-in-c-pointer-ch-1-2/"/>
    <id>https://brainku.github.io/2014/09/15/deep-in-c-pointer-ch-1-2/</id>
    <published>2014-09-15T10:34:02.000Z</published>
    <updated>2016-08-20T12:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-1-认识指针"><a href="#Chap-1-认识指针" class="headerlink" title="Chap 1 认识指针"></a>Chap 1 认识指针</h1><h2 id="1-1-指针与内存"><a href="#1-1-指针与内存" class="headerlink" title="1.1 指针与内存"></a>1.1 指针与内存</h2><p>C使用内存的方式有三种：</p>
<ol>
<li>静态/全局内存<br> 变量在程序开始时分配,知道程序终止时被清除. 全局变量均可访问,静态变量则只在函数定义域内可以.</li>
<li>自动内存<br> 在函数内部声明,且在函数被调用时才创建.仅限函数调用期间可使用和生存.</li>
<li>动态内存<br> 分配在堆上的内存.可以根据需要来分配和释放.</li>
</ol>
<a id="more"></a>
<blockquote>
<p>如何阅读一个指针变量声明?<br>const int* pi <strong>一个指向整型常量的指针变量</strong><br>试着从右往左去理解.</p>
</blockquote>
<h2 id="1-1-8-关于NULL"><a href="#1-1-8-关于NULL" class="headerlink" title="1.1.8 关于NULL"></a>1.1.8 关于NULL</h2><p>一个自定义的宏<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></div></pre></td></tr></table></figure></p>
<p>可以使用这种方式来决定循环是否退出:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* pi...</div><div class="line"><span class="keyword">if</span> (pi) &#123;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>void指针: 通用指针.用来存放任何类型的指针引用.<br>两个有趣的性质(?):</p>
<ol>
<li>void指针具有与char指针相同的形式和内存对齐方式</li>
<li>void指针和别的指针永远不会相等,除非都是为NULL的void指针.</li>
</ol>
<p>任何指针都可以被赋给void指针,它也可以被转换回原来的指针类型.<br>void指针只能做数据指针,而不能用做函数指针.</p>
<h2 id="1-2-2-size-t"><a href="#1-2-2-size-t" class="headerlink" title="1.2.2 size_t"></a>1.2.2 size_t</h2><p>size_t是C中任何对象所能达到的最大长度,它是一个<strong>无符号整数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>要特别注意循环中的情况:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个循环永远不会退出. 一般不会这么用错,但是要注意 <strong> <code>strlen()</code> 和 <code>sizeof()</code> 返回的都是size_t</strong></p>
</blockquote>
<h2 id="1-3-1-指针算数运算"><a href="#1-3-1-指针算数运算" class="headerlink" title="1.3.1 指针算数运算"></a>1.3.1 指针算数运算</h2><p>指针的加法: 内存地址偏移 = <strong>对应整数 * 指针数据类型对应字节数</strong><br>减法同理.<br>不过要注意void指针的情况–不建议对其进行算数运算(不过地址也可能偏移就是了,偏移量会是4字节(32位机器))</p>
<h2 id="1-4-1-多层间接引用"><a href="#1-4-1-多层间接引用" class="headerlink" title="1.4.1 多层间接引用"></a>1.4.1 多层间接引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *title[] = &#123;<span class="string">"111"</span>, <span class="string">"222"</span>, <span class="string">"333"</span>&#125;;</div><div class="line"><span class="comment">//大致上跟多维数组类似. 只是如果是多维数组会略麻烦,后面那维是必须给出-这跟C的数组表示形式有关-c多维数组在内存空间上是‘一维’的</span></div><div class="line"><span class="keyword">char</span> title[][<span class="number">3</span>] = &#123;...&#125;;</div></pre></td></tr></table></figure>
<h2 id="1-4-2-常量和指针"><a href="#1-4-2-常量和指针" class="headerlink" title="1.4.2 常量和指针"></a>1.4.2 常量和指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = <span class="number">5</span>; </div><div class="line"><span class="comment">//只是限制不可以通过pi修改对应的值;pi可以指向另外一个变量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pi = &amp;limit; <span class="comment">// 指向常量的整型指针---实际指向的可以不是常量;←_←他觉得自己就是指向常量的(虽然实际上它可以不是)</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span>* pi = &amp;limit; <span class="comment">// 跟上面等价</span></div><div class="line"><span class="comment">//指向常量会报错,因为这里可以赋值.</span></div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> pi; <span class="comment">//指向非常量的常量指针. pi必须指向非常量,pi不可以指向其他变量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> pi; <span class="comment">// 指向常量的常量指针,似乎没多大意义</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> *pi; <span class="comment">// 指向"指向常量的常量指针"的指针= =</span></div></pre></td></tr></table></figure>
<h1 id="Chap2-C的动态内存管理"><a href="#Chap2-C的动态内存管理" class="headerlink" title="Chap2 C的动态内存管理"></a>Chap2 C的动态内存管理</h1><h2 id="2-1-动态内存管理"><a href="#2-1-动态内存管理" class="headerlink" title="2.1  动态内存管理"></a>2.1  动态内存管理</h2><ul>
<li>C的动态内存管理: 管理的对象即从堆上分配的内存.通常是手动分配和释放的过程.(c上也存在gc的实现,只是非标准)</li>
</ul>
<h4 id="动态分配内存的步骤"><a href="#动态分配内存的步骤" class="headerlink" title="动态分配内存的步骤:"></a>动态分配内存的步骤:</h4><ol>
<li>使用malloc类的函数分配内存,返回void指针</li>
<li>使用返回的内存</li>
<li>使用free释放对应的内存</li>
</ol>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><ul>
<li><p>丢失内存地址–分配了内存,但是无法使用. 常见于在函数中分配内存,但是未正确返回创建的地址.<br>在这个例子中,name做完循环之后就指向了原本的尾巴.前面’test’所占的内存无法利用,也无法释放.(这种情况,建议放到函数中来做)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* name=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="string">"test"</span>)+<span class="number">1</span>);</div><div class="line"><span class="built_in">strcpy</span>(name, <span class="string">"test"</span>);</div><div class="line"><span class="keyword">while</span> (*name != <span class="number">0</span>) &#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, name);</div><div class="line">	name++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>未调用frre–也就是忘记释放该释放的内存.无法使用对应的内存,堆可用空间越来越少.</p>
</li>
</ul>
<h2 id="2-2-动态内存分配函数"><a href="#2-2-动态内存分配函数" class="headerlink" title="2.2 动态内存分配函数"></a>2.2 动态内存分配函数</h2><p>分配的内存会根据指针的数据类型对齐. 如4字节的整数会被分配在能被4整除的边界上.</p>
<ol>
<li><code>malloc(size_t)</code> 在堆上直接分一块内存.返回void指针,<strong>如果分配失败返回NULL(以下同理)</strong>. 这个函数不会修改内存的数据,可以认为分配的内存中包含脏数据.<br><strong>Warning:全局和静态变量不可以在初始化的时候调用malloc分配内存,该操作需要放在函数中执行</strong></li>
<li><p><code>calloc(size_t numEle, size_t eleSize)</code> 分配的同时清空内存.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*) <span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="comment">//等价 不过一般情况下calloc可能会比malloc慢</span></div><div class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">5</span>);</div><div class="line"><span class="built_in">memset</span>(pi, <span class="number">0</span>, <span class="keyword">sizeof</span>(pi));</div></pre></td></tr></table></figure>
</li>
<li><p><code>realloc(void* ptr, size_t)</code>重新分配内存.</p>
</li>
</ol>
<ul>
<li>如果分配的大小小于原本则裁剪</li>
<li>如果分配的大小大于原本,则先在本地试着增加,否则就另找一块足够</li>
<li>大的空间来进行分配,并复制到新区域.</li>
<li>如果为0, 则释放原本的内存块(类似于free)</li>
</ul>
<h2 id="2-3-关于free"><a href="#2-3-关于free" class="headerlink" title="2.3 关于free"></a>2.3 关于free</h2><p>重复调用free会导致错误(将一块已经归还系统的内存再归还是不可能的~)<br><strong>将已释放的指针赋值为NULL</strong>,以防止迷途指针.</p>
<h2 id="2-4-迷途指针"><a href="#2-4-迷途指针" class="headerlink" title="2.4 迷途指针"></a>2.4 迷途指针</h2><p>如果内存已经释放,而指针仍然还在引用原本的内存-也就是野指针,迷途指针(过早释放).<br>可能造成的问题:</p>
<ol>
<li>如果通过它访问内存,则行为不可预期</li>
<li>如果内存不可访问,则是段错误</li>
<li>潜在的安全隐患</li>
</ol>
<p>常见的错误:</p>
<ol>
<li>释放指针后仍然对指定地址进行修改;</li>
<li>指针别名–其中一指针释放了内存,但是另外一别名仍然继续访问.</li>
</ol>
<blockquote>
<p>Ku: 跟Java不同的一种内存泄露现象.考虑下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi;</div><div class="line">&#123;  <span class="keyword">int</span> tmp = <span class="number">5</span>; pi = &amp;tmp; &#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>在外面声明一个变量,然后在另一代码块中赋值,在Java中似乎可以接受.但在这里, pi指向的是tmp这一变量,而tmp是只在该栈帧中存在的,在大括号结束之后,tmp所在栈帧就出栈了.调用foo()导致入栈,那么pi指向的就是foo()中的某块不知名内存. 也就成为了野指针.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chap-1-认识指针&quot;&gt;&lt;a href=&quot;#Chap-1-认识指针&quot; class=&quot;headerlink&quot; title=&quot;Chap 1 认识指针&quot;&gt;&lt;/a&gt;Chap 1 认识指针&lt;/h1&gt;&lt;h2 id=&quot;1-1-指针与内存&quot;&gt;&lt;a href=&quot;#1-1-指针与内存&quot; class=&quot;headerlink&quot; title=&quot;1.1 指针与内存&quot;&gt;&lt;/a&gt;1.1 指针与内存&lt;/h2&gt;&lt;p&gt;C使用内存的方式有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态/全局内存&lt;br&gt; 变量在程序开始时分配,知道程序终止时被清除. 全局变量均可访问,静态变量则只在函数定义域内可以.&lt;/li&gt;
&lt;li&gt;自动内存&lt;br&gt; 在函数内部声明,且在函数被调用时才创建.仅限函数调用期间可使用和生存.&lt;/li&gt;
&lt;li&gt;动态内存&lt;br&gt; 分配在堆上的内存.可以根据需要来分配和释放.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://brainku.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="https://brainku.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>打鸡血=。=</title>
    <link href="https://brainku.github.io/2014/08/24/da-ji-xue/"/>
    <id>https://brainku.github.io/2014/08/24/da-ji-xue/</id>
    <published>2014-08-23T18:14:00.000Z</published>
    <updated>2016-08-20T13:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>绝大多数时候，凑合着做完，比完美地半途而废要好。<br>绝大多数时候，决定要做就直接开始，比自认为准备充分了再开始要好。</p>
<p>脑内山水千万里，不如脚下一步。哪怕是跌出去的一步。</p>
<p>这个思维方式是我花了很长时间很大精力去养成的，至今都没有完全贯彻到行动中去，但多少有点进步。如果能真正实行，拖延症估计就好了吧。</p>
</blockquote>
<a id="more"></a> 
<p>打鸡血时间，我连个时间管理软件都没写出来呢！</p>
<blockquote>
<p><strong>你自己在利用这一大段时间练习的时候，每次都要给自己足够难但是又刚好可以做出来的题目来做。</strong>等到你把这个题目做出来，你就会觉得很多问题便容易了，这个时候你重复的解决他们只能得到很小的锻炼，于是你要自己寻找更难的题目，一个足够难但是又刚好可以做出来的题目。当然找到一个好的题目也不是那么容易的，反正年轻的时候时间都是不值钱的，等你试图做几个题目发现自己根本做不出来的时候，你就知道什么叫做刚好可以做出来了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;绝大多数时候，凑合着做完，比完美地半途而废要好。&lt;br&gt;绝大多数时候，决定要做就直接开始，比自认为准备充分了再开始要好。&lt;/p&gt;
&lt;p&gt;脑内山水千万里，不如脚下一步。哪怕是跌出去的一步。&lt;/p&gt;
&lt;p&gt;这个思维方式是我花了很长时间很大精力去养成的，至今都没有完全贯彻到行动中去，但多少有点进步。如果能真正实行，拖延症估计就好了吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭好了，我的github博客</title>
    <link href="https://brainku.github.io/2014/08/23/first-try-to-jekyll/"/>
    <id>https://brainku.github.io/2014/08/23/first-try-to-jekyll/</id>
    <published>2014-08-23T09:14:00.000Z</published>
    <updated>2016-08-20T12:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一个下午之后终于把本地的Jekyll环境搭好并且运行起来了，可喜可贺。<br>说到我为什么要建博客，大概是因为一直没找到一个<em>省钱</em>又省心的环境来写些记录吧。最近又开始在想，虽然我一直都有在记录思维导图，但是思维导图也是有些碎片化了吧。没有好好整理自己的想法的话，会像是在重造轮子。<br><a id="more"></a><br>举个栗子，比如原先我看了某个博客，理解了某段内容，如果没有按照自己的想法记录下来，下次再看到似乎也是一个再消化的过程。<br>在举个栗子，阅读了别人的自定义控件之后，我尝试按照自己的想法写自己的控件。这个写控件的过程就是一个遇到问题，再查找资料，最终解决问题的过程。如果不记录这个过程，或者说<em>因为思维导图的关系</em>无法详细描述。下次再遇到这样子的问题，你可以记住那些”原本不重要的”细节吗？<br>所以呢，搭个博客来写写感想还是蛮不错的吧~域名的事再另外考虑，写博客是个积累的过程嘛。现在只是开始，不急。</p>
<hr>
<p>在搭博客的过程中参考了多位大牛的资料，贴在下面以防下次出问题方便查找~<br><a href="https://github.com/beiyuu" target="_blank" rel="external">BeeYuu</a>        <a href="http://beiyuu.com/github-pages" target="_blank" rel="external">使用Github Pages建独立博客 </a><br><a href="http://jekyll-windows.juthilo.com/" target="_blank" rel="external">Run Jekyll on Windows</a><br><a href="http://jekyllrb.com/docs/home/" target="_blank" rel="external">Jekyll 官方文档</a><br><a href="http://chxt6896.github.io/blog/2012/02/13/blog-jekyll-native.html" target="_blank" rel="external">Jekyll本地调试</a>  </p>
<hr>
<blockquote>
<p>21:18</p>
</blockquote>
<p>继续写下我遇到的事情。<br>我本来想在PHPStorm里面写下HTML跟CSS之类的，但是似乎没办法的样子诶。<br>PHPStorm是支持SASS跟SCSS，但是Jekyll的CSS文件里面有部分加了自己的语法- -<br><del>我现在就觉得Jekyll的sass目录结构有病，导入的先后顺序应该不是那个样子的吧？</del><br>好像如果在页面的开始标注上— —-的话Jekyll会按照自己的语法规则来处理scss。删掉的话会怎样？<br>尝试了一下，发现真的无法处理正常的结构目录。</p>
<blockquote>
<p>00:25</p>
</blockquote>
<p>发现了一个OctoPress的东西，这东西把Jekyll封装了起来，而且还加了很多主题~今晚就折腾这个东西过去了。<br>感觉还是git比较花时间啊= =几个命令都不熟来着。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一个下午之后终于把本地的Jekyll环境搭好并且运行起来了，可喜可贺。&lt;br&gt;说到我为什么要建博客，大概是因为一直没找到一个&lt;em&gt;省钱&lt;/em&gt;又省心的环境来写些记录吧。最近又开始在想，虽然我一直都有在记录思维导图，但是思维导图也是有些碎片化了吧。没有好好整理自己的想法的话，会像是在重造轮子。&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://brainku.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
